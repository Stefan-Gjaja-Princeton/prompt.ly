# IMPORTANT NOTE: This was generated by Cursor, it contains the functions that apiService.js calls from the frontend.
from flask import Flask, request, jsonify, Response, stream_with_context
from flask_cors import CORS
from config import Config
from database import Database
from ai_service import AIService
from auth_service import require_auth
import uuid
from datetime import datetime, timezone
import os
import json

app = Flask(__name__)

# Configure CORS based on environment
if Config.ENVIRONMENT == 'production':
    # Production: allow only the frontend URL with explicit CORS settings
    # Some browsers require explicit allowed methods and headers
    CORS(
        app, 
        origins=[Config.FRONTEND_URL], 
        supports_credentials=True,
        methods=['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
        allow_headers=['Content-Type', 'Authorization'],
        expose_headers=['Content-Type'],
        max_age=3600
    )
else:
    # Development: allow all origins
    CORS(
        app,
        supports_credentials=True,
        methods=['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
        allow_headers=['Content-Type', 'Authorization']
    )

# Initialize database contact
db = Database()

# Check if API key is available, this code was put in place when I was struggling with API issues
if not Config.OPENAI_API_KEY or Config.OPENAI_API_KEY == "your-api-key-here":
    print("ERROR: OpenAI API key not found!")
    print("Please set your API key in one of these ways:")
    print("1. Edit backend/api_key.py and replace 'your-api-key-here' with your actual key")
    print("2. Set environment variable: export OPENAI_API_KEY='your-key-here'")
    print("3. Create backend/.env file with: OPENAI_API_KEY=your-key-here")
    exit(1)

# starts up the OpenAI API service
ai_service = AIService(Config.OPENAI_API_KEY)

# Initialize message cache (in-memory storage for messages with base64 data)
# Cache expires after 5 minutes to prevent memory leaks
app._message_cache = {}
app._message_cache_timestamps = {}

def extract_user_name(user_data, user_from_db=None):
    """Extract user's first name from Auth0 data or database, with fallbacks"""
    # Option 1 - gets from database
    if user_from_db and user_from_db.get('first_name'):
        return user_from_db['first_name']
    
    # Second option - gets from Auth0 name field
    name = user_data.get('name')
    if isinstance(name, list) and len(name) > 0:
        return name[0]
    elif isinstance(name, str) and name.strip():
        return name.strip().split()[0]
    
    # Could also have auth0 nickname
    nickname = user_data.get('nickname')
    if nickname:
        return nickname
    
    # Email prefix (last resort)
    email = user_data.get('email', '')
    if email:
        return email.split('@')[0]
    
    return None

# a health check to make sure app is running and endpoints reachable
@app.route('/api/health', methods=['GET'])
def health_check():
    return jsonify({"status": "healthy"})

# get user profile endpoint for display on homepage top ribbon
@app.route('/api/user/profile', methods=['GET'])
@require_auth
def get_user_profile():
    """Get current user profile"""
    try:
        user_data = request.current_user
        
        # Get or create user in database
        email = user_data['email']
        existing_user = db.get_user_by_email(email)
        
        # Parse name from Auth0 data
        # Auth0 name can be a string (e.g., "John Doe") or None
        name = user_data.get('name')
        if isinstance(name, list):
            # If it's already a list from our parsing
            first_name = name[0] if len(name) > 0 else None
            last_name = name[1] if len(name) > 1 else None
        elif isinstance(name, str) and name.strip():
            # Split full name into first and last
            name_parts = name.strip().split(maxsplit=1)
            first_name = name_parts[0] if len(name_parts) > 0 else None
            last_name = name_parts[1] if len(name_parts) > 1 else None
        else:
            # Fallback to nickname or email prefix
            first_name = user_data.get('nickname') or (email.split('@')[0] if email else None)
            last_name = None
        
        google_id = user_data.get('sub')
        profile_picture_url = user_data.get('picture')
        
        if not existing_user:
            # Create new user from Auth0 data if they don't currently exist in DB
            db.create_user(
                email=email,
                first_name=first_name,
                last_name=last_name,
                google_id=google_id,
                profile_picture_url=profile_picture_url
            )
            existing_user = db.get_user_by_email(email)
        else:
            # Update profile information for existing users
            # Update fields that are missing in database or have new values from Auth0
            should_update = False
            update_first_name = None
            update_last_name = None
            update_google_id = None
            update_picture = None
            
            # Update first_name if missing or different
            if first_name and (not existing_user.get('first_name') or existing_user.get('first_name') != first_name):
                update_first_name = first_name
                should_update = True
            
            # Update last_name if missing or different
            if last_name and (not existing_user.get('last_name') or existing_user.get('last_name') != last_name):
                update_last_name = last_name
                should_update = True
            
            # Update google_id if missing or different
            if google_id and (not existing_user.get('google_id') or existing_user.get('google_id') != google_id):
                update_google_id = google_id
                should_update = True
            
            # Update profile_picture_url if missing or different
            if profile_picture_url and (not existing_user.get('profile_picture_url') or existing_user.get('profile_picture_url') != profile_picture_url):
                update_picture = profile_picture_url
                should_update = True
            
            if should_update:
                db.update_user_profile(
                    email=email,
                    first_name=update_first_name,
                    last_name=update_last_name,
                    google_id=update_google_id,
                    profile_picture_url=update_picture
                )
                # Refresh user data after update
                existing_user = db.get_user_by_email(email)
            else:
                # Just update last login if nothing else changed
                db.update_user_login(email)
                # Refresh to get updated last_login
                existing_user = db.get_user_by_email(email)
        
        return jsonify(existing_user)
    except Exception as e:
        return jsonify({"error": str(e)}), 500

# get all conversations from a specific user endpoint (this is the main conversation list)
@app.route('/api/conversations', methods=['GET'])
@require_auth
def get_conversations():
    """Get all conversations for the authenticated user with pagination optional if I decide to enable that for potential speedup"""
    try:
        user_email = request.current_user.get('email')
        if not user_email:
            return jsonify({"error": "User email not found"}), 500
        
        # Get pagination parameters (default: limit=50, offset=0)
        limit = request.args.get('limit', type=int)
        offset = request.args.get('offset', type=int, default=0)
        
        # Use new method that fetches all summaries in a single query
        conversations = db.get_user_conversation_summaries(user_email, limit=limit, offset=offset)
        
        return jsonify(conversations)
    except Exception as e:
        print(f"ERROR in get_conversations endpoint: {e}")
        import traceback
        print(traceback.format_exc())
        return jsonify({"error": str(e)}), 500

# endpoint to make a new convo (user sends a message)
@app.route('/api/conversations', methods=['POST'])
@require_auth
def create_conversation():
    """Create a new conversation"""
    try:
        user_email = request.current_user['email']
        # unique identifier uuid for the database to use as the primary key
        conversation_id = str(uuid.uuid4())
        
        # Ensure user exists in DB, doesn't do anything if already in there
        db.create_user(user_email)
        
        # Create conversation
        success = db.create_conversation(user_email, conversation_id)
        
        if success:
            return jsonify({
                "conversation_id": conversation_id,
                "message": "Conversation created successfully"
            })
        else:
            return jsonify({"error": "Failed to create conversation"}), 500
            
    except Exception as e:
        return jsonify({"error": str(e)}), 500

# endpoint to get a speific conversation (when users click on the frontend)
@app.route('/api/conversations/<conversation_id>', methods=['GET'])
@require_auth
def get_conversation(conversation_id):
    """Get a specific conversation, optionally limiting to last N messages"""
    try:
        # Get limit parameter (default: None = load all messages, since conversations are capped at 20 user messages)
        # For very long conversations, you can pass limit_messages to load only recent ones (just a structure put into place in case I remove the 20 messages cap in the future)
        limit_messages = request.args.get('limit_messages', type=int)
        conversation = db.get_conversation(conversation_id, limit_messages=limit_messages)
        if conversation:
            return jsonify(conversation)
        else:
            return jsonify({"error": "Conversation not found"}), 404
    except Exception as e:
        return jsonify({"error": str(e)}), 500

# endpoint to send a message in a specific conversation
@app.route('/api/conversations/<conversation_id>/messages', methods=['POST'])
@require_auth
def send_message(conversation_id):
    """Send a message to a conversation. Creates the conversation if it doesn't exist."""
    try:
        data = request.get_json()
        user_message = data.get('message', '') if data else ''
        # Support both old format (file_attachment) and new format (file_attachments array)
        file_attachment = data.get('file_attachment', None) if data else None
        file_attachments = data.get('file_attachments', None) if data else None
        
        # Normalize to array format for consistent processing
        if file_attachment and not file_attachments:
            # Old format: single file, convert to array
            file_attachments = [file_attachment]
        elif not file_attachments:
            file_attachments = []
        
        # Allow message to be empty if files are attached
        if not user_message and len(file_attachments) == 0:
            return jsonify({"error": "Message or file attachment is required"}), 400
        
        # Validate file types if attachments are provided
        if len(file_attachments) > 0:
            # Limit to 3 attachments
            if len(file_attachments) > 3:
                return jsonify({"error": "Maximum of 3 file attachments allowed"}), 400
            
            for file_attachment in file_attachments:
                file_type = file_attachment.get("file_type", "")
                filename = file_attachment.get("filename", "")
                # Check if it's a valid type (image or PDF)
                is_image = file_type.startswith("image/") or any(
                    filename.lower().endswith(ext) for ext in ['.png', '.jpg', '.jpeg']
                )
                is_pdf = file_type == "application/pdf" or filename.lower().endswith('.pdf')
                
                if not (is_image or is_pdf):
                    return jsonify({"error": "Only image files (PNG, JPG) and PDFs are supported"}), 400
        
        user_email = request.current_user['email']
        
        # Get current conversation, create it if it doesn't exist
        conversation = db.get_conversation(conversation_id)
        if not conversation:
            # Conversation doesn't exist - create it now (this happens when user clicks plus button but hasn't sent a message yet)
            # Ensure user exists in DB (idempotent function I think is the right word)
            db.create_user(user_email)
            # Create conversation with the provided conversation_id
            success = db.create_conversation(user_email, conversation_id)
            if not success:
                return jsonify({"error": "Failed to create conversation"}), 500
            # Get the newly created conversation
            conversation = db.get_conversation(conversation_id)
            if not conversation:
                return jsonify({"error": "Failed to retrieve created conversation"}), 500
        else:
            # Validate that existing conversation belongs to the authenticated user
            conv_user_email = conversation.get('user_email')
            if conv_user_email != user_email:
                return jsonify({"error": "Conversation not found"}), 404
        
        messages = conversation.get('messages', [])
        if not isinstance(messages, list):
            messages = []
        
        # Count existing user messages (not including AI responses)
        user_message_count = sum(1 for msg in messages if msg.get('role') == 'user')
        
        # Check if conversation has reached the 20 user message limit
        if user_message_count >= 20:
            print(f"ERROR: Conversation {conversation_id} has reached limit with {user_message_count} messages")
            return jsonify({
                "error": "Conversation limit reached",
                "message": "This conversation has reached the maximum of 20 user messages. Please start a new conversation to continue."
            }), 400
        
        current_quality_score = conversation['quality_score'] or 5.0  # Default to 5.0 for AI response if no score yet
        previous_scores = conversation.get('message_scores', [])
        
        # Add user message with optional file attachments
        user_msg = {
            "role": "user",
            "content": user_message or "",
            "timestamp": datetime.now(timezone.utc).isoformat()
        }
        
        # Add file attachments metadata if provided (up to 3)
        if len(file_attachments) > 0:
            user_msg["attachments"] = [
                {
                    "filename": att.get("filename", "image"),
                    "file_type": att.get("file_type", "image/jpeg"),
                    # Store base64 data temporarily for AI processing
                    "data": att.get("data")
                }
                for att in file_attachments
            ]
        
        messages.append(user_msg)
        
        # Get feedback and score FIRST (before AI response) just so its not all coming at once
        # Pass messages with attachments - the feedback model will extract PDF text and note images
        quality_score, feedback, current_message_score = ai_service.get_feedback_response(messages, previous_scores)
        
        # Generate title if no title exists yet and we have at least one user message
        # Title remains fixed once generated (only generate if existing_title is None)
        title = None
        existing_title = conversation.get('title')
        user_messages = [msg for msg in messages if msg.get('role') == 'user']
        
        if not existing_title and len(user_messages) > 0:  # No title yet but we have user messages
            try:
                # Use the first user message to generate the title
                # Pass the config flag to control AI generation vs old behavior
                from config import Config
                title = ai_service.get_conversation_title(
                    [user_messages[0]], 
                    use_ai_generation=Config.USE_AI_TITLE_GENERATION
                )
            except Exception as e:
                print(f"WARNING: Failed to generate conversation title: {e}")
                # Fallback to first message content if title generation fails
                first_user_msg = user_messages[0].get('content', '')
                title = first_user_msg[:50] + "..." if len(first_user_msg) > 50 else first_user_msg
        
        # Prepare messages for storage (remove base64 data, keep only metadata)
        messages_for_storage = []
        for msg in messages:
            msg_copy = msg.copy()
            if 'attachments' in msg_copy:
                # Keep only metadata, remove base64 data
                msg_copy['attachments'] = [
                    {
                        'filename': att.get('filename'),
                        'file_type': att.get('file_type')
                    }
                    for att in msg_copy['attachments']
                ]
            messages_for_storage.append(msg_copy)
        
        # Update conversation with new messages, quality score, and feedback FIRST
        # Serialize feedback dict to JSON string for storage
        new_message_scores = previous_scores + [current_message_score]
        feedback_json = json.dumps(feedback) if isinstance(feedback, dict) else feedback
        db.update_conversation(conversation_id, messages_for_storage, quality_score, new_message_scores, feedback_json, title=title)
        
        
        import time
        # Initialize cache if it doesn't exist (shouldn't happen after startup, but just in case)
        if not hasattr(app, '_message_cache'):
            app._message_cache = {}
            app._message_cache_timestamps = {}
        
        # Clean up old cache entries first (older than 5 minutes)
        # shouldn't need to do this but just prevents memory leaks (if the user reloads the page mid response)
        current_time = time.time()
        expired_keys = [
            key for key, timestamp in list(app._message_cache_timestamps.items())
            if current_time - timestamp > 300
        ]
        for key in expired_keys:
            app._message_cache.pop(key, None)
            app._message_cache_timestamps.pop(key, None)
        
        # Store new messages with base64 for AI processing
        app._message_cache[conversation_id] = messages
        app._message_cache_timestamps[conversation_id] = current_time
        
        # Get updated conversation to retrieve the title (which may have been generated)
        updated_conversation = db.get_conversation(conversation_id)
        updated_title = updated_conversation.get('title') if updated_conversation else None
        
        # Return feedback immediately (before AI response)
        # Return messages with metadata only (no base64 data)
        return jsonify({
            "feedback_ready": True,
            "quality_score": quality_score,
            "feedback": feedback,
            "messages": messages_for_storage,
            "title": updated_title  # Include the title if it was generated
        })
        
    except Exception as e:
        print(f"ERROR in send_message endpoint: {e}")
        import traceback
        print(traceback.format_exc())
        return jsonify({"error": str(e)}), 500

# endpoint to get ai response after the feedback is given (streaming)
@app.route('/api/conversations/<conversation_id>/response', methods=['POST'])
@require_auth
def get_ai_response(conversation_id):
    """Get streaming AI response for a conversation after feedback is ready"""
    try:
        # Get current conversation
        conversation = db.get_conversation(conversation_id)
        if not conversation:
            print(f"ERROR: Conversation {conversation_id} not found")
            return jsonify({"error": "Conversation not found"}), 404
        
        # Try to get messages with base64 from cache (for AI processing)
        # If not in cache, use messages from database (which only have metadata)
        messages = None
        
        # Check cache and clean up expired entries
        import time
        if hasattr(app, '_message_cache') and hasattr(app, '_message_cache_timestamps'):
            current_time = time.time()
            # Check if cache entry exists and is not expired
            if conversation_id in app._message_cache:
                cache_age = current_time - app._message_cache_timestamps.get(conversation_id, 0)
                if cache_age < 300:  # Cache valid for 5 minutes
                    # get the stuff from the cache
                    messages = app._message_cache[conversation_id]
                    # Remove from cache after use (one-time use)
                    del app._message_cache[conversation_id]
                    app._message_cache_timestamps.pop(conversation_id, None)
                else:
                    # Expired cache entry - remove it
                    app._message_cache.pop(conversation_id, None)
                    app._message_cache_timestamps.pop(conversation_id, None)
            
            # Clean up any other expired entries while we're at it
            expired_keys = [
                key for key, timestamp in list(app._message_cache_timestamps.items())
                if current_time - timestamp > 300
            ]
            for key in expired_keys:
                app._message_cache.pop(key, None)
                app._message_cache_timestamps.pop(key, None)
        
        # Fallback to database messages if not in cache
        if not messages:
            messages = conversation.get('messages', [])
            
        # Ensure messages list is valid
        if not isinstance(messages, list):
            print(f"WARNING: Messages is not a list, resetting to empty list")
            messages = []
        
        if not messages:
            print(f"ERROR: No messages in conversation {conversation_id}")
            return jsonify({"error": "No messages in conversation"}), 400
        
        current_quality_score = conversation.get('quality_score') or 5.0
        
        # Get user's first name for personalization
        user_email = request.current_user.get('email')
        user_data = request.current_user
        user_from_db = db.get_user_by_email(user_email) if user_email else None
        
        # Extract name using helper function
        first_name = extract_user_name(user_data, user_from_db)
        
        # Parse full name from Auth0 for potential profile update
        name = user_data.get('name')
        if isinstance(name, list):
            auth0_first_name = name[0] if len(name) > 0 else None
            auth0_last_name = name[1] if len(name) > 1 else None
        elif isinstance(name, str) and name.strip():
            name_parts = name.strip().split(maxsplit=1)
            auth0_first_name = name_parts[0] if len(name_parts) > 0 else None
            auth0_last_name = name_parts[1] if len(name_parts) > 1 else None
        else:
            auth0_first_name = user_data.get('nickname')
            auth0_last_name = None
        
        # Update profile if name is missing in database or Auth0 has better/updated data
        db_first_name = user_from_db.get('first_name') if user_from_db else None
        email_prefix = user_email.split('@')[0] if user_email else ''
        should_update_profile = False
        
        # Update if name is missing in database
        if not db_first_name and auth0_first_name and auth0_first_name != email_prefix:
            should_update_profile = True
        # Update if Auth0 has a real name but database has email prefix
        elif db_first_name == email_prefix and auth0_first_name and auth0_first_name != email_prefix:
            should_update_profile = True
        
        if should_update_profile and user_from_db:
            try:
                db.update_user_profile(
                    email=user_email,
                    first_name=auth0_first_name,
                    last_name=auth0_last_name,
                    google_id=user_data.get('sub'),
                    profile_picture_url=user_data.get('picture')
                )
                # Refresh from database after update
                user_from_db = db.get_user_by_email(user_email)
                first_name = extract_user_name(user_data, user_from_db)
            except Exception as e:
                print(f"WARNING: Failed to update profile: {e}")
        
        def generate_stream():
            """Generator function that yields Server-Sent Events"""
            full_response = ""
            try:
                import time
                import sys
                
                
                from ai_service import AIService
                
                # Debug: Check if messages have image attachments
                has_images = any(
                    msg.get('attachments') and any(att.get('data') for att in msg.get('attachments', []))
                    for msg in messages if msg.get('role') == 'user'
                )

                # Check if model supports streaming (o1 models don't, but gpt-5 models do)
                if not ai_service._supports_streaming(ai_service.response_model):
                    # o1 models don't support streaming - use non-streaming method and basically pretend its streaming for consistent user behavior
                    ai_response = ai_service.get_chat_response(messages, current_quality_score, user_name=first_name)
                    
                    if not ai_response:
                        raise ValueError("AI response is empty")
                    
                    # Simulate streaming by sending the response in chunks with delays
                    # Split by words to make it more natural, but include a few words per chunk
                    words = ai_response.split(' ')
                    words_per_chunk = 2  # Send 2 words at a time for smoother streaming
                    for i in range(0, len(words), words_per_chunk):
                        chunk_words = words[i:i + words_per_chunk]
                        chunk = ' '.join(chunk_words)
                        if i + words_per_chunk < len(words):
                            chunk += ' '  # Add space after chunk if not last
                        full_response += chunk
                        # Send chunk as Server-Sent Event
                        data = f"data: {json.dumps({'chunk': chunk})}\n\n"
                        yield data
                        # Delay to make streaming visible (50ms per chunk for smooth effect)
                        time.sleep(0.05)
                    
                else:
                    # Stream AI response for models that support it (gpt-5 models, gpt-4o, etc.)
                    for chunk in ai_service.get_chat_response_stream(messages, current_quality_score, user_name=first_name):
                        if chunk:
                            full_response += chunk
                            # Send chunk as Server-Sent Event
                            data = f"data: {json.dumps({'chunk': chunk})}\n\n"
                            yield data
                
                # Add complete AI response to messages
                ai_message = {
                    "role": "assistant",
                    "content": full_response,
                    "timestamp": datetime.now(timezone.utc).isoformat()
                }
                messages.append(ai_message)
                
                # Update conversation with AI response (preserve existing feedback)
                existing_feedback = conversation.get('feedback')
                existing_feedback_json = json.dumps(existing_feedback) if isinstance(existing_feedback, dict) else existing_feedback
                db.update_conversation(conversation_id, messages, current_quality_score, conversation.get('message_scores', []), existing_feedback_json)
                
                # Send completion signal
                yield f"data: {json.dumps({'done': True, 'full_response': full_response})}\n\n"
                
            except Exception as ai_error:
                error_type = type(ai_error).__name__
                error_msg = str(ai_error)
                print(f"ERROR: Failed to generate AI response ({error_type}): {error_msg}")
                import traceback
                traceback_str = traceback.format_exc()
                print(f"ERROR: Traceback: {traceback_str}")
                
                # Provide more helpful error messages
                user_friendly_error = "Failed to generate AI response"
                if "rate limit" in error_msg.lower():
                    user_friendly_error = "Rate limit exceeded. Please try again in a moment."
                elif "connection" in error_msg.lower() or "network" in error_msg.lower():
                    user_friendly_error = "Connection error. Please check your internet connection."
                elif "invalid" in error_msg.lower() or "authentication" in error_msg.lower():
                    user_friendly_error = "API authentication error. Please check your API key configuration."
                
                yield f"data: {json.dumps({'error': user_friendly_error, 'details': error_msg, 'type': error_type})}\n\n"
        
        return Response(
            stream_with_context(generate_stream()),
            mimetype='text/event-stream',
            headers={
                'Cache-Control': 'no-cache',
                'X-Accel-Buffering': 'no',
                'Connection': 'keep-alive'
            }
        )
        
    except Exception as e:
        error_msg = str(e)
        print(f"ERROR: Unexpected error in get_ai_response: {error_msg}")
        import traceback
        print(f"ERROR: Traceback: {traceback.format_exc()}")
        return jsonify({
            "error": "Server error occurred",
            "details": error_msg
        }), 500

if __name__ == '__main__':
    print("Starting Prompt.ly backend server...")
    print(f"Environment: {Config.ENVIRONMENT}")
    
    port = int(os.getenv('PORT', 5001))
    app.run(debug=Config.DEBUG, host='0.0.0.0', port=port)
