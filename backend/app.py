# IMPORTANT NOTE: This was generated by Cursor, it contains the functions that apiService.js calls from the frontend.
from flask import Flask, request, jsonify
from flask_cors import CORS
from config import Config
from database import Database
from ai_service import AIService
from auth_service import require_auth
import uuid
from datetime import datetime
import os

app = Flask(__name__)

# Configure CORS based on environment
if Config.ENVIRONMENT == 'production':
    # Production: allow only the frontend URL with explicit CORS settings
    # Some browsers require explicit allowed methods and headers
    CORS(
        app, 
        origins=[Config.FRONTEND_URL], 
        supports_credentials=True,
        methods=['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
        allow_headers=['Content-Type', 'Authorization'],
        expose_headers=['Content-Type'],
        max_age=3600
    )
else:
    # Development: allow all origins
    CORS(
        app,
        supports_credentials=True,
        methods=['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
        allow_headers=['Content-Type', 'Authorization']
    )

# Initialize services
db = Database()

# Check if API key is available
if not Config.OPENAI_API_KEY or Config.OPENAI_API_KEY == "your-api-key-here":
    print("âŒ ERROR: OpenAI API key not found!")
    print("Please set your API key in one of these ways:")
    print("1. Edit backend/api_key.py and replace 'your-api-key-here' with your actual key")
    print("2. Set environment variable: export OPENAI_API_KEY='your-key-here'")
    print("3. Create backend/.env file with: OPENAI_API_KEY=your-key-here")
    exit(1)

ai_service = AIService(Config.OPENAI_API_KEY)

@app.route('/api/health', methods=['GET'])
def health_check():
    return jsonify({"status": "healthy"})

# User profile endpoint
@app.route('/api/user/profile', methods=['GET'])
@require_auth
def get_user_profile():
    """Get current user profile"""
    try:
        user_data = request.current_user
        
        # Get or create user in database
        email = user_data['email']
        existing_user = db.get_user_by_email(email)
        
        if not existing_user:
            # Create new user from Auth0 data
            name = user_data.get('name', [])
            if isinstance(name, list) and len(name) > 0:
                first_name = name[0]
                last_name = name[1] if len(name) > 1 else ''
            else:
                first_name = user_data.get('nickname', '') or user_data.get('email', '').split('@')[0] if user_data.get('email') else ''
                last_name = ''
            
            db.create_user(
                email=email,
                first_name=first_name or user_data.get('nickname', ''),
                last_name=last_name,
                google_id=user_data.get('sub'),
                profile_picture_url=user_data.get('picture')
            )
            existing_user = db.get_user_by_email(email)
        else:
            # Update last login
            db.update_user_login(email)
        
        return jsonify(existing_user)
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/api/conversations', methods=['GET'])
@require_auth
def get_conversations():
    """Get all conversations for the authenticated user"""
    try:
        user_email = request.current_user.get('email')
        if not user_email:
            return jsonify({"error": "User email not found"}), 500
        
        conversation_ids = db.get_user_conversations(user_email)
        conversations = []
        
        for conv_id in conversation_ids:
            summary = db.get_conversation_summary(conv_id)
            if summary:
                conversations.append(summary)
        
        # Sort by updated_at descending
        conversations.sort(key=lambda x: x['updated_at'], reverse=True)
        return jsonify(conversations)
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/api/conversations', methods=['POST'])
@require_auth
def create_conversation():
    """Create a new conversation"""
    try:
        user_email = request.current_user['email']
        conversation_id = str(uuid.uuid4())
        
        # Ensure user exists in DB (idempotent)
        db.create_user(user_email)
        
        # Create conversation
        success = db.create_conversation(user_email, conversation_id)
        
        if success:
            return jsonify({
                "conversation_id": conversation_id,
                "message": "Conversation created successfully"
            })
        else:
            return jsonify({"error": "Failed to create conversation"}), 500
            
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/api/conversations/<conversation_id>', methods=['GET'])
@require_auth
def get_conversation(conversation_id):
    """Get a specific conversation"""
    try:
        conversation = db.get_conversation(conversation_id)
        if conversation:
            return jsonify(conversation)
        else:
            return jsonify({"error": "Conversation not found"}), 404
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/api/conversations/<conversation_id>/messages', methods=['POST'])
@require_auth
def send_message(conversation_id):
    """Send a message to a conversation"""
    try:
        data = request.get_json()
        user_message = data.get('message', '')
        
        if not user_message:
            return jsonify({"error": "Message is required"}), 400
        
        # Get current conversation
        conversation = db.get_conversation(conversation_id)
        if not conversation:
            return jsonify({"error": "Conversation not found"}), 404
        
        messages = conversation['messages']
        current_quality_score = conversation['quality_score'] or 5.0  # Default to 5.0 for AI response if no score yet
        previous_scores = conversation.get('message_scores', [])
        
        # Add user message
        messages.append({
            "role": "user",
            "content": user_message,
            "timestamp": datetime.now().isoformat()
        })
        
        # Get feedback and score FIRST (before AI response)
        quality_score, feedback, current_message_score = ai_service.get_feedback_response(messages, previous_scores)
        
        # Update conversation with new messages, quality score, and feedback FIRST
        new_message_scores = previous_scores + [current_message_score]
        db.update_conversation(conversation_id, messages, quality_score, new_message_scores, feedback)
        
        # Return feedback immediately (before AI response)
        return jsonify({
            "feedback_ready": True,
            "quality_score": quality_score,
            "feedback": feedback,
            "messages": messages
        })
        
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/api/conversations/<conversation_id>/response', methods=['POST'])
@require_auth
def get_ai_response(conversation_id):
    """Get AI response for a conversation after feedback is ready"""
    try:
        # Get current conversation
        conversation = db.get_conversation(conversation_id)
        if not conversation:
            print(f"ERROR: Conversation {conversation_id} not found")
            return jsonify({"error": "Conversation not found"}), 404
        
        messages = conversation.get('messages', [])
        if not messages:
            print(f"ERROR: No messages in conversation {conversation_id}")
            return jsonify({"error": "No messages in conversation"}), 400
        
        current_quality_score = conversation.get('quality_score') or 5.0
        
        # Get user's first name for personalization
        user_data = request.current_user
        name = user_data.get('name', [])
        if isinstance(name, list) and len(name) > 0:
            first_name = name[0]
        else:
            first_name = user_data.get('nickname', '') or user_data.get('email', '').split('@')[0] if user_data.get('email') else ''
        
        print(f"DEBUG: Getting AI response for conversation {conversation_id}")
        print(f"DEBUG: Messages count: {len(messages)}")
        print(f"DEBUG: Quality score: {current_quality_score}")
        print(f"DEBUG: User name: {first_name}")
        print(f"DEBUG: Last message: {messages[-1] if messages else 'None'}")
        
        # Get AI response using the current score
        try:
            ai_response = ai_service.get_chat_response(messages, current_quality_score, user_name=first_name)
            
            if not ai_response:
                raise ValueError("AI response is empty")
            
            print(f"DEBUG: AI response received: {ai_response[:100]}...")
        except Exception as ai_error:
            error_msg = str(ai_error)
            print(f"ERROR: Failed to generate AI response: {error_msg}")
            import traceback
            traceback_str = traceback.format_exc()
            print(f"ERROR: Traceback: {traceback_str}")
            return jsonify({
                "error": "Failed to generate AI response",
                "details": error_msg,
                "type": type(ai_error).__name__
            }), 500
        
        # Add AI response to messages
        messages.append({
            "role": "assistant",
            "content": ai_response,
            "timestamp": datetime.now().isoformat()
        })
        
        # Update conversation with AI response (preserve existing feedback)
        existing_feedback = conversation.get('feedback')
        db.update_conversation(conversation_id, messages, current_quality_score, conversation.get('message_scores', []), existing_feedback)
        
        return jsonify({
            "ai_response": ai_response,
            "messages": messages
        })
        
    except Exception as e:
        error_msg = str(e)
        print(f"ERROR: Unexpected error in get_ai_response: {error_msg}")
        import traceback
        print(f"ERROR: Traceback: {traceback.format_exc()}")
        return jsonify({
            "error": "Server error occurred",
            "details": error_msg
        }), 500

@app.route('/api/conversations/<conversation_id>/title', methods=['PUT'])
@require_auth
def update_conversation_title(conversation_id):
    """Update conversation title (for future use)"""
    try:
        data = request.get_json()
        title = data.get('title', '')
        
        # This would require adding a title field to the database
        # For now, just return success
        return jsonify({"message": "Title updated successfully"})
        
    except Exception as e:
        return jsonify({"error": str(e)}), 500

if __name__ == '__main__':
    print("Starting Prompt.ly backend server...")
    print(f"Environment: {Config.ENVIRONMENT}")
    print(f"Debug mode: {Config.DEBUG}")
    
    port = int(os.getenv('PORT', 5001))
    app.run(debug=Config.DEBUG, host='0.0.0.0', port=port)
