# IMPORTANT NOTE: This was generated by Cursor, it contains the functions that apiService.js calls from the frontend.
from flask import Flask, request, jsonify, Response, stream_with_context
from flask_cors import CORS
from config import Config
from database import Database
from ai_service import AIService
from auth_service import require_auth
import uuid
from datetime import datetime
import os
import json

app = Flask(__name__)

# Configure CORS based on environment
if Config.ENVIRONMENT == 'production':
    # Production: allow only the frontend URL with explicit CORS settings
    # Some browsers require explicit allowed methods and headers
    CORS(
        app, 
        origins=[Config.FRONTEND_URL], 
        supports_credentials=True,
        methods=['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
        allow_headers=['Content-Type', 'Authorization'],
        expose_headers=['Content-Type'],
        max_age=3600
    )
else:
    # Development: allow all origins
    CORS(
        app,
        supports_credentials=True,
        methods=['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
        allow_headers=['Content-Type', 'Authorization']
    )

# Initialize database contact
db = Database()

# Check if API key is available
if not Config.OPENAI_API_KEY or Config.OPENAI_API_KEY == "your-api-key-here":
    print("ERROR: OpenAI API key not found!")
    print("Please set your API key in one of these ways:")
    print("1. Edit backend/api_key.py and replace 'your-api-key-here' with your actual key")
    print("2. Set environment variable: export OPENAI_API_KEY='your-key-here'")
    print("3. Create backend/.env file with: OPENAI_API_KEY=your-key-here")
    exit(1)

ai_service = AIService(Config.OPENAI_API_KEY)

def extract_user_name(user_data, user_from_db=None):
    """Extract user's first name from Auth0 data or database, with fallbacks"""
    # Priority 1: Database
    if user_from_db and user_from_db.get('first_name'):
        return user_from_db['first_name']
    
    # Priority 2: Auth0 name field
    name = user_data.get('name')
    if isinstance(name, list) and len(name) > 0:
        return name[0]
    elif isinstance(name, str) and name.strip():
        return name.strip().split()[0]
    
    # Priority 3: Auth0 nickname
    nickname = user_data.get('nickname')
    if nickname:
        return nickname
    
    # Priority 4: Email prefix (last resort)
    email = user_data.get('email', '')
    if email:
        return email.split('@')[0]
    
    return None

# a health check to make sure app is running and endpoints reachable
@app.route('/api/health', methods=['GET'])
def health_check():
    return jsonify({"status": "healthy"})

# get user profile endpoint
@app.route('/api/user/profile', methods=['GET'])
@require_auth
def get_user_profile():
    """Get current user profile"""
    try:
        user_data = request.current_user
        
        # Get or create user in database
        email = user_data['email']
        existing_user = db.get_user_by_email(email)
        
        # Parse name from Auth0 data
        # Auth0 name can be a string (e.g., "John Doe") or None
        name = user_data.get('name')
        if isinstance(name, list):
            # If it's already a list from our parsing
            first_name = name[0] if len(name) > 0 else None
            last_name = name[1] if len(name) > 1 else None
        elif isinstance(name, str) and name.strip():
            # Split full name into first and last
            name_parts = name.strip().split(maxsplit=1)
            first_name = name_parts[0] if len(name_parts) > 0 else None
            last_name = name_parts[1] if len(name_parts) > 1 else None
        else:
            # Fallback to nickname or email prefix
            first_name = user_data.get('nickname') or (email.split('@')[0] if email else None)
            last_name = None
        
        google_id = user_data.get('sub')
        profile_picture_url = user_data.get('picture')
        
        if not existing_user:
            # Create new user from Auth0 data
            db.create_user(
                email=email,
                first_name=first_name,
                last_name=last_name,
                google_id=google_id,
                profile_picture_url=profile_picture_url
            )
            existing_user = db.get_user_by_email(email)
        else:
            # Update profile information for existing users
            # Update fields that are missing in database or have new values from Auth0
            should_update = False
            update_first_name = None
            update_last_name = None
            update_google_id = None
            update_picture = None
            
            # Update first_name if missing or different
            if first_name and (not existing_user.get('first_name') or existing_user.get('first_name') != first_name):
                update_first_name = first_name
                should_update = True
            
            # Update last_name if missing or different
            if last_name and (not existing_user.get('last_name') or existing_user.get('last_name') != last_name):
                update_last_name = last_name
                should_update = True
            
            # Update google_id if missing or different
            if google_id and (not existing_user.get('google_id') or existing_user.get('google_id') != google_id):
                update_google_id = google_id
                should_update = True
            
            # Update profile_picture_url if missing or different
            if profile_picture_url and (not existing_user.get('profile_picture_url') or existing_user.get('profile_picture_url') != profile_picture_url):
                update_picture = profile_picture_url
                should_update = True
            
            if should_update:
                db.update_user_profile(
                    email=email,
                    first_name=update_first_name,
                    last_name=update_last_name,
                    google_id=update_google_id,
                    profile_picture_url=update_picture
                )
                # Refresh user data after update
                existing_user = db.get_user_by_email(email)
            else:
                # Just update last login if nothing else changed
                db.update_user_login(email)
                # Refresh to get updated last_login
                existing_user = db.get_user_by_email(email)
        
        return jsonify(existing_user)
    except Exception as e:
        return jsonify({"error": str(e)}), 500

# get all conversations from a specific user endpoint
@app.route('/api/conversations', methods=['GET'])
@require_auth
def get_conversations():
    """Get all conversations for the authenticated user with pagination"""
    try:
        user_email = request.current_user.get('email')
        if not user_email:
            return jsonify({"error": "User email not found"}), 500
        
        # Get pagination parameters (default: limit=50, offset=0)
        limit = request.args.get('limit', type=int)
        offset = request.args.get('offset', type=int, default=0)
        
        # Use new method that fetches all summaries in a single query
        conversations = db.get_user_conversation_summaries(user_email, limit=limit, offset=offset)
        
        return jsonify(conversations)
    except Exception as e:
        return jsonify({"error": str(e)}), 500

# endpoint to make a new convo
@app.route('/api/conversations', methods=['POST'])
@require_auth
def create_conversation():
    """Create a new conversation"""
    try:
        user_email = request.current_user['email']
        # unique identifier
        conversation_id = str(uuid.uuid4())
        
        # Ensure user exists in DB, doesn't do anything if already in there
        db.create_user(user_email)
        
        # Create conversation
        success = db.create_conversation(user_email, conversation_id)
        
        if success:
            return jsonify({
                "conversation_id": conversation_id,
                "message": "Conversation created successfully"
            })
        else:
            return jsonify({"error": "Failed to create conversation"}), 500
            
    except Exception as e:
        return jsonify({"error": str(e)}), 500

# endpoint to get a speific conversation
@app.route('/api/conversations/<conversation_id>', methods=['GET'])
@require_auth
def get_conversation(conversation_id):
    """Get a specific conversation"""
    try:
        conversation = db.get_conversation(conversation_id)
        if conversation:
            return jsonify(conversation)
        else:
            return jsonify({"error": "Conversation not found"}), 404
    except Exception as e:
        return jsonify({"error": str(e)}), 500

# endpoint to send a message in a specific conversation
@app.route('/api/conversations/<conversation_id>/messages', methods=['POST'])
@require_auth
def send_message(conversation_id):
    """Send a message to a conversation"""
    try:
        data = request.get_json()
        user_message = data.get('message', '')
        
        if not user_message:
            return jsonify({"error": "Message is required"}), 400
        
        # Get current conversation
        conversation = db.get_conversation(conversation_id)
        if not conversation:
            return jsonify({"error": "Conversation not found"}), 404
        
        messages = conversation['messages']
        
        # Count existing user messages (not including AI responses)
        user_message_count = sum(1 for msg in messages if msg.get('role') == 'user')
        
        # Check if conversation has reached the 20 user message limit
        if user_message_count >= 20:
            return jsonify({
                "error": "Conversation limit reached",
                "message": "This conversation has reached the maximum of 20 user messages. Please start a new conversation to continue."
            }), 400
        
        current_quality_score = conversation['quality_score'] or 5.0  # Default to 5.0 for AI response if no score yet
        previous_scores = conversation.get('message_scores', [])
        
        # Add user message
        messages.append({
            "role": "user",
            "content": user_message,
            "timestamp": datetime.now().isoformat()
        })
        
        # Get feedback and score FIRST (before AI response) just so its not all coming at once
        quality_score, feedback, current_message_score = ai_service.get_feedback_response(messages, previous_scores)
        
        # Generate title if no title exists yet and we have at least one user message
        title = None
        existing_title = conversation.get('title')
        user_messages = [msg for msg in messages if msg.get('role') == 'user']
        
        if not existing_title and len(user_messages) > 0:  # No title yet but we have user messages
            try:
                # Use the first user message to generate the title
                title = ai_service.get_conversation_title([user_messages[0]])
                print(f"DEBUG: Generated conversation title: {title}")
            except Exception as e:
                print(f"WARNING: Failed to generate conversation title: {e}")
                # Fallback to first message content if title generation fails
                first_user_msg = user_messages[0].get('content', '')
                title = first_user_msg[:50] + "..." if len(first_user_msg) > 50 else first_user_msg
        
        # Update conversation with new messages, quality score, and feedback FIRST
        # Serialize feedback dict to JSON string for storage
        new_message_scores = previous_scores + [current_message_score]
        feedback_json = json.dumps(feedback) if isinstance(feedback, dict) else feedback
        db.update_conversation(conversation_id, messages, quality_score, new_message_scores, feedback_json, title=title)
        
        # Get updated conversation to retrieve the title (which may have been generated)
        updated_conversation = db.get_conversation(conversation_id)
        updated_title = updated_conversation.get('title') if updated_conversation else None
        
        # Return feedback immediately (before AI response)
        return jsonify({
            "feedback_ready": True,
            "quality_score": quality_score,
            "feedback": feedback,
            "messages": messages,
            "title": updated_title  # Include the title if it was generated
        })
        
    except Exception as e:
        return jsonify({"error": str(e)}), 500

# endpoint to get ai response after the feedback is given (streaming)
@app.route('/api/conversations/<conversation_id>/response', methods=['POST'])
@require_auth
def get_ai_response(conversation_id):
    """Get streaming AI response for a conversation after feedback is ready"""
    try:
        # Get current conversation
        conversation = db.get_conversation(conversation_id)
        if not conversation:
            print(f"ERROR: Conversation {conversation_id} not found")
            return jsonify({"error": "Conversation not found"}), 404
        
        messages = conversation.get('messages', [])
        if not messages:
            print(f"ERROR: No messages in conversation {conversation_id}")
            return jsonify({"error": "No messages in conversation"}), 400
        
        current_quality_score = conversation.get('quality_score') or 5.0
        
        # Get user's first name for personalization
        user_email = request.current_user.get('email')
        user_data = request.current_user
        user_from_db = db.get_user_by_email(user_email) if user_email else None
        
        # Extract name using helper function
        first_name = extract_user_name(user_data, user_from_db)
        
        # Parse full name from Auth0 for potential profile update
        name = user_data.get('name')
        if isinstance(name, list):
            auth0_first_name = name[0] if len(name) > 0 else None
            auth0_last_name = name[1] if len(name) > 1 else None
        elif isinstance(name, str) and name.strip():
            name_parts = name.strip().split(maxsplit=1)
            auth0_first_name = name_parts[0] if len(name_parts) > 0 else None
            auth0_last_name = name_parts[1] if len(name_parts) > 1 else None
        else:
            auth0_first_name = user_data.get('nickname')
            auth0_last_name = None
        
        # Update profile if name is missing in database or Auth0 has better/updated data
        db_first_name = user_from_db.get('first_name') if user_from_db else None
        email_prefix = user_email.split('@')[0] if user_email else ''
        should_update_profile = False
        
        # Update if name is missing in database
        if not db_first_name and auth0_first_name and auth0_first_name != email_prefix:
            should_update_profile = True
        # Update if Auth0 has a real name but database has email prefix
        elif db_first_name == email_prefix and auth0_first_name and auth0_first_name != email_prefix:
            should_update_profile = True
        
        if should_update_profile and user_from_db:
            try:
                db.update_user_profile(
                    email=user_email,
                    first_name=auth0_first_name,
                    last_name=auth0_last_name,
                    google_id=user_data.get('sub'),
                    profile_picture_url=user_data.get('picture')
                )
                # Refresh from database after update
                user_from_db = db.get_user_by_email(user_email)
                first_name = extract_user_name(user_data, user_from_db)
            except Exception as e:
                print(f"WARNING: Failed to update profile: {e}")
        
        def generate_stream():
            """Generator function that yields Server-Sent Events"""
            full_response = ""
            try:
                import time
                import sys
                
                # Check if model supports streaming (reasoning models don't)
                from ai_service import AIService
                if ai_service._is_reasoning_model(ai_service.response_model):
                    # Reasoning models don't support streaming - use non-streaming method and simulate streaming
                    print(f"DEBUG: Using non-streaming method for reasoning model {ai_service.response_model}")
                    ai_response = ai_service.get_chat_response(messages, current_quality_score, user_name=first_name)
                    
                    if not ai_response:
                        raise ValueError("AI response is empty")
                    
                    # Simulate streaming by sending the response in chunks with delays
                    # Split by words to make it more natural, but include a few words per chunk
                    words = ai_response.split(' ')
                    words_per_chunk = 2  # Send 2 words at a time for smoother streaming
                    for i in range(0, len(words), words_per_chunk):
                        chunk_words = words[i:i + words_per_chunk]
                        chunk = ' '.join(chunk_words)
                        if i + words_per_chunk < len(words):
                            chunk += ' '  # Add space after chunk if not last
                        full_response += chunk
                        # Send chunk as Server-Sent Event
                        data = f"data: {json.dumps({'chunk': chunk})}\n\n"
                        yield data
                        # Delay to make streaming visible (50ms per chunk for smooth effect)
                        time.sleep(0.05)
                    
                else:
                    # Stream AI response for models that support it
                    for chunk in ai_service.get_chat_response_stream(messages, current_quality_score, user_name=first_name):
                        if chunk:
                            full_response += chunk
                            # Send chunk as Server-Sent Event
                            data = f"data: {json.dumps({'chunk': chunk})}\n\n"
                            yield data
                
                # Add complete AI response to messages
                ai_message = {
                    "role": "assistant",
                    "content": full_response,
                    "timestamp": datetime.now().isoformat()
                }
                messages.append(ai_message)
                
                # Update conversation with AI response (preserve existing feedback)
                existing_feedback = conversation.get('feedback')
                existing_feedback_json = json.dumps(existing_feedback) if isinstance(existing_feedback, dict) else existing_feedback
                db.update_conversation(conversation_id, messages, current_quality_score, conversation.get('message_scores', []), existing_feedback_json)
                
                # Send completion signal
                yield f"data: {json.dumps({'done': True, 'full_response': full_response})}\n\n"
                
            except Exception as ai_error:
                error_msg = str(ai_error)
                print(f"ERROR: Failed to generate AI response: {error_msg}")
                import traceback
                traceback_str = traceback.format_exc()
                print(f"ERROR: Traceback: {traceback_str}")
                yield f"data: {json.dumps({'error': 'Failed to generate AI response', 'details': error_msg})}\n\n"
        
        return Response(
            stream_with_context(generate_stream()),
            mimetype='text/event-stream',
            headers={
                'Cache-Control': 'no-cache',
                'X-Accel-Buffering': 'no',
                'Connection': 'keep-alive'
            }
        )
        
    except Exception as e:
        error_msg = str(e)
        print(f"ERROR: Unexpected error in get_ai_response: {error_msg}")
        import traceback
        print(f"ERROR: Traceback: {traceback.format_exc()}")
        return jsonify({
            "error": "Server error occurred",
            "details": error_msg
        }), 500

@app.route('/api/conversations/<conversation_id>/title', methods=['PUT'])
@require_auth
def update_conversation_title(conversation_id):
    """Update conversation title"""
    try:
        data = request.get_json()
        title = data.get('title', '')
        
        if not title:
            return jsonify({"error": "Title is required"}), 400
        
        # Get conversation to update
        conversation = db.get_conversation(conversation_id)
        if not conversation:
            return jsonify({"error": "Conversation not found"}), 404
        
        # Update just the title
        db.update_conversation(
            conversation_id,
            conversation.get('messages', []),
            conversation.get('quality_score', 5.0),
            conversation.get('message_scores', []),
            conversation.get('feedback'),
            title=title
        )
        
        return jsonify({"message": "Title updated successfully"})
        
    except Exception as e:
        return jsonify({"error": str(e)}), 500

if __name__ == '__main__':
    print("Starting Prompt.ly backend server...")
    print(f"Environment: {Config.ENVIRONMENT}")
    print(f"Debug mode: {Config.DEBUG}")
    
    port = int(os.getenv('PORT', 5001))
    app.run(debug=Config.DEBUG, host='0.0.0.0', port=port)
