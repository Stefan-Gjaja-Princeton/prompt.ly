# IMPORTANT NOTE: This was generated by Cursor to test the endpoints.
"""
Integration tests for app.py API endpoints
Tests full request/response cycle with mocked dependencies
"""
import pytest
import json
from unittest.mock import patch, MagicMock, Mock
from flask import Flask
from app import app

class TestAppIntegration:
    """Integration tests for Flask app endpoints"""
    
    @pytest.fixture
    def client(self):
        """Create test client"""
        app.config['TESTING'] = True
        with app.test_client() as client:
            yield client
    
    def test_health_check(self, client):
        """Test health check endpoint"""
        response = client.get('/api/health')
        assert response.status_code == 200
        data = json.loads(response.data)
        assert data['status'] == 'healthy'
    
    @patch('app.db')
    @patch('auth_service.auth_service')
    def test_get_user_profile(self, mock_auth_service, mock_db, client):
        """Test getting user profile"""
        # Mock get_user_from_token to return user data
        mock_auth_service.get_user_from_token.return_value = {
            "sub": "auth0|123",
            "email": "test@example.com",
            "name": ["Test", "User"],
            "nickname": "testuser"
        }
        
        mock_user = {
            "email": "test@example.com",
            "first_name": "Test",
            "last_name": "User"
        }
        mock_db.get_user_by_email.return_value = mock_user
        
        # Add Authorization header
        response = client.get('/api/user/profile', headers={'Authorization': 'Bearer test-token'})
        assert response.status_code == 200
    
    @patch('app.db')
    @patch('auth_service.auth_service')
    def test_create_conversation(self, mock_auth_service, mock_db, client):
        """Test creating a new conversation"""
        # Mock get_user_from_token to return user data
        mock_auth_service.get_user_from_token.return_value = {"email": "test@example.com"}
        
        mock_db.create_user.return_value = True
        mock_db.create_conversation.return_value = True
        
        response = client.post('/api/conversations', headers={'Authorization': 'Bearer test-token'})
        assert response.status_code == 200
        data = json.loads(response.data)
        assert 'conversation_id' in data
    
    @patch('app.db')
    @patch('app.ai_service')
    @patch('auth_service.auth_service')
    def test_send_message(self, mock_auth_service, mock_ai_service, mock_db, client):
        """Test sending a message to a conversation"""
        # Mock get_user_from_token to return user data
        mock_auth_service.get_user_from_token.return_value = {"email": "test@example.com"}
        
        # Mock conversation - first call returns None (doesn't exist), then returns conversation
        # The endpoint calls get_conversation multiple times: 
        # 1. Check if exists (returns None)
        # 2. After creation (returns conversation)
        # 3. After update to get title (returns updated conversation)
        mock_conversation = {
            "conversation_id": "test-123",
            "user_email": "test@example.com",
            "messages": [],
            "quality_score": None,
            "message_scores": [],
            "title": None
        }
        mock_conversation_updated = mock_conversation.copy()
        mock_conversation_updated["title"] = "Test Conversation"
        mock_db.get_conversation.side_effect = [None, mock_conversation, mock_conversation_updated]
        mock_db.create_user.return_value = True
        mock_db.create_conversation.return_value = True
        mock_db.update_conversation.return_value = True
        
        # Mock AI service - feedback is now a dict
        mock_feedback = {
            "quality_label": "Good",
            "improvement_tips": ["Be more specific", "Add context", "Ask focused questions"],
            "example_improved_prompt": "Example prompt"
        }
        mock_ai_service.get_feedback_response.return_value = (7.5, mock_feedback, 7.5)
        mock_ai_service.get_conversation_title.return_value = "Test Conversation"
        
        response = client.post(
            '/api/conversations/test-123/messages',
            json={"message": "Hello"},
            headers={'Authorization': 'Bearer test-token'}
        )
        assert response.status_code == 200
        data = json.loads(response.data)
        assert 'feedback_ready' in data
        assert 'quality_score' in data
    
    @patch('app.db')
    @patch('app.ai_service')
    @patch('auth_service.auth_service')
    def test_get_ai_response(self, mock_auth_service, mock_ai_service, mock_db, client):
        """Test getting AI response (streaming)"""
        # Mock get_user_from_token to return user data
        mock_auth_service.get_user_from_token.return_value = {
            "email": "test@example.com",
            "name": ["Test"],
            "nickname": "testuser"
        }
        
        # Mock conversation with messages
        mock_conversation = {
            "conversation_id": "test-123",
            "user_email": "test@example.com",
            "messages": [
                {"role": "user", "content": "Hello", "timestamp": "2024-01-01T00:00:00"}
            ],
            "quality_score": 7.5,
            "message_scores": [7.5]
        }
        mock_db.get_conversation.return_value = mock_conversation
        mock_db.get_user_by_email.return_value = {"first_name": "Test"}
        mock_db.update_conversation.return_value = True
        
        # Mock AI service - simulate streaming response
        def mock_stream():
            yield "This "
            yield "is "
            yield "an AI response."
        
        # Mock the _supports_streaming method and get_chat_response_stream
        mock_ai_service._supports_streaming.return_value = True
        mock_ai_service.response_model = "gpt-4o"
        mock_ai_service.get_chat_response_stream.return_value = mock_stream()
        
        response = client.post('/api/conversations/test-123/response', headers={'Authorization': 'Bearer test-token'})
        assert response.status_code == 200
        assert 'text/event-stream' in response.content_type
        
        # Parse SSE response - should contain chunks
        response_data = response.data.decode('utf-8')
        # Should contain SSE format data
        assert 'data:' in response_data
    
    def test_get_conversations_requires_auth(self, client):
        """Test that conversations endpoint requires authentication"""
        # Without auth, should return 401
        response = client.get('/api/conversations')
        assert response.status_code == 401

