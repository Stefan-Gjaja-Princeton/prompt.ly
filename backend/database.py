# IMPORTANT NOTE: This was generated by Cursor to set up and manage the overhead
# operations of the database.
import os
import json
from datetime import datetime
from typing import List, Dict, Optional
from config import Config

# Determine which database to use based on DATABASE_URL
DATABASE_URL = os.getenv('DATABASE_URL') or Config.DATABASE_URL

# PostgreSQL support (Render may use postgres:// or postgresql://)
USE_POSTGRES = DATABASE_URL and (DATABASE_URL.startswith('postgresql://') or DATABASE_URL.startswith('postgres://'))

if USE_POSTGRES:
    try:
        import psycopg2
        from psycopg2.extras import RealDictCursor
        import psycopg2.pool
        print("Using PostgreSQL database")
    except ImportError:
        print("WARNING: psycopg2 not installed. Install with: pip install psycopg2-binary")
        USE_POSTGRES = False

# SQLite fallback - but on render version won't fall back
if not USE_POSTGRES:
    import sqlite3
    print("Using SQLite database")

class Database:
    def __init__(self, db_path: str = "promptly.db"):
        self.use_postgres = USE_POSTGRES
        self.db_path = db_path
        self.database_url = DATABASE_URL
        
        if self.use_postgres:
            self._init_postgres()
        else:
            self.clear_locks()
        
        self.init_database()
    
    def _init_postgres(self):
        """Initialize PostgreSQL connection pool"""
        try:
            # Parse DATABASE_URL and create connection
            # Render provides DATABASE_URL like: postgresql://user:pass@host:port/dbname
            self.conn_pool = None  # We'll use direct connections for simplicity
            print(f"PostgreSQL database URL configured")
        except Exception as e:
            print(f"Error initializing PostgreSQL: {e}")
            self.use_postgres = False
    
    def _get_connection(self):
        """Get database connection (PostgreSQL or SQLite)"""
        if self.use_postgres:
            import psycopg2
            
            # psycopg2.connect can handle both postgres:// and postgresql:// URLs directly
            conn = psycopg2.connect(
                self.database_url,
                connect_timeout=10
            )
            conn.autocommit = False
            return conn
        else:
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            conn.execute("PRAGMA journal_mode=WAL")
            return conn
    
    # deprecate this, not used any more
    def _execute_query(self, query: str, params: tuple = None, fetch_one: bool = False, fetch_all: bool = False):
        """Execute a query and return results"""
        conn = None
        try:
            conn = self._get_connection()
            cursor = conn.cursor()
            
            # Convert SQLite-style ? placeholders to PostgreSQL %s if needed
            if self.use_postgres and '?' in query:
                query = query.replace('?', '%s')
            
            if params:
                cursor.execute(query, params)
            else:
                cursor.execute(query)
            
            if fetch_one:
                result = cursor.fetchone()
                if self.use_postgres and result:
                    # Convert tuple to list for consistency
                    result = list(result)
                return result
            elif fetch_all:
                results = cursor.fetchall()
                if self.use_postgres:
                    # Convert tuples to lists
                    results = [list(r) for r in results]
                return results
            
            conn.commit()
            return None
        except Exception as e:
            if conn:
                conn.rollback()
            print(f"Error executing query: {e}")
            raise
        finally:
            if conn:
                conn.close()
    
    def clear_locks(self):
        """Clear any existing database locks (SQLite only)"""
        if self.use_postgres:
            return
        
        try:
            import os
            wal_file = f"{self.db_path}-wal"
            shm_file = f"{self.db_path}-shm"
            
            if os.path.exists(wal_file):
                os.remove(wal_file)
            if os.path.exists(shm_file):
                os.remove(shm_file)
        except Exception as e:
            print(f"Warning: Could not clear database locks: {e}")
    
    # makes the database that I use
    def init_database(self):
        """Initialize the database with required tables"""
        conn = None
        try:
            conn = self._get_connection()
            cursor = conn.cursor()
            
            if self.use_postgres:
                # PostgreSQL table creation
                # Create users table
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS users (
                        email VARCHAR(255) PRIMARY KEY,
                        first_name VARCHAR(255),
                        last_name VARCHAR(255),
                        google_id VARCHAR(255),
                        profile_picture_url TEXT,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        last_login TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                    )
                ''')
                
                # Create conversations table
                # can just use this to fetch the conversations
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS conversations (
                        conversation_id VARCHAR(255) PRIMARY KEY,
                        user_email VARCHAR(255),
                        messages TEXT,
                        current_quality_score REAL DEFAULT NULL,
                        current_feedback TEXT DEFAULT NULL,
                        message_scores TEXT,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        FOREIGN KEY (user_email) REFERENCES users (email) ON DELETE CASCADE
                    )
                ''')
            else:
                # SQLite table creation (original)
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS users (
                        email TEXT PRIMARY KEY,
                        first_name TEXT,
                        last_name TEXT,
                        google_id TEXT,
                        profile_picture_url TEXT,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        last_login TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                    )
                ''')
                
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS conversations (
                        conversation_id TEXT PRIMARY KEY,
                        user_email TEXT,
                        messages TEXT,
                        current_quality_score REAL DEFAULT NULL,
                        current_feedback TEXT DEFAULT NULL,
                        message_scores TEXT,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        FOREIGN KEY (user_email) REFERENCES users (email)
                    )
                ''')
            
            # Add current_feedback column if it doesn't exist (for existing databases) - was when I was porting over
            if self.use_postgres:
                # PostgreSQL: Check if column exists
                cursor.execute('''
                    SELECT column_name 
                    FROM information_schema.columns 
                    WHERE table_name='conversations' AND column_name='current_feedback'
                ''')
                if not cursor.fetchone():
                    cursor.execute('ALTER TABLE conversations ADD COLUMN current_feedback TEXT DEFAULT NULL')
            else:
                # SQLite: Try to add column (will fail silently if exists)
                try:
                    cursor.execute('ALTER TABLE conversations ADD COLUMN current_feedback TEXT DEFAULT NULL')
                except sqlite3.OperationalError:
                    pass  # Column already exists
            
            conn.commit()
        except Exception as e:
            print(f"Error initializing database: {e}")
            if conn:
                conn.rollback()
        finally:
            if conn:
                conn.close()
    
    def create_user(self, email: str, first_name: str = None, last_name: str = None, google_id: str = None, profile_picture_url: str = None) -> bool:
        """Create a new user (doesn't do anything for existing users)"""
        conn = None
        try:
            conn = self._get_connection()
            cursor = conn.cursor()
            
            if self.use_postgres:
                cursor.execute(
                    "INSERT INTO users (email, first_name, last_name, google_id, profile_picture_url) VALUES (%s, %s, %s, %s, %s) ON CONFLICT (email) DO NOTHING",
                    (email, first_name, last_name, google_id, profile_picture_url)
                )
            else:
                cursor.execute(
                    "INSERT OR IGNORE INTO users (email, first_name, last_name, google_id, profile_picture_url) VALUES (?, ?, ?, ?, ?)",
                    (email, first_name, last_name, google_id, profile_picture_url)
                )
            
            conn.commit()
            return True
        except Exception as e:
            print(f"Error creating user: {e}")
            if conn:
                conn.rollback()
            return False
        finally:
            if conn:
                conn.close()
    
    def get_user_by_email(self, email: str) -> Optional[Dict]:
        """Fetch a user record by email"""
        conn = None
        try:
            conn = self._get_connection()
            cursor = conn.cursor()
            
            if self.use_postgres:
                cursor.execute(
                    "SELECT email, first_name, last_name, google_id, profile_picture_url, created_at, last_login FROM users WHERE email = %s",
                    (email,)
                )
            else:
                cursor.execute(
                    "SELECT email, first_name, last_name, google_id, profile_picture_url, created_at, last_login FROM users WHERE email = ?",
                    (email,)
                )
            
            row = cursor.fetchone()
            if not row:
                return None
            
            return {
                'email': row[0],
                'first_name': row[1],
                'last_name': row[2],
                'google_id': row[3],
                'profile_picture_url': row[4],
                'created_at': str(row[5]) if row[5] else None,
                'last_login': str(row[6]) if row[6] else None,
            }
        except Exception as e:
            print(f"Error getting user by email: {e}")
            return None
        finally:
            if conn:
                conn.close()
    
    def update_user_login(self, email: str) -> None:
        """Update last_login when a user signs in"""
        conn = None
        try:
            conn = self._get_connection()
            cursor = conn.cursor()
            
            if self.use_postgres:
                cursor.execute("UPDATE users SET last_login = CURRENT_TIMESTAMP WHERE email = %s", (email,))
            else:
                cursor.execute("UPDATE users SET last_login = CURRENT_TIMESTAMP WHERE email = ?", (email,))
            
            conn.commit()
        except Exception as e:
            print(f"Error updating user last_login: {e}")
            if conn:
                conn.rollback()
        finally:
            if conn:
                conn.close()
    
    def update_user_profile(self, email: str, first_name: str = None, last_name: str = None, google_id: str = None, profile_picture_url: str = None) -> bool:
        """Update user profile information"""
        conn = None
        try:
            conn = self._get_connection()
            cursor = conn.cursor()
            
            # Build update query dynamically based on what's provided
            updates = []
            values = []
            
            if first_name is not None:
                updates.append("first_name = %s" if self.use_postgres else "first_name = ?")
                values.append(first_name)
            if last_name is not None:
                updates.append("last_name = %s" if self.use_postgres else "last_name = ?")
                values.append(last_name)
            if google_id is not None:
                updates.append("google_id = %s" if self.use_postgres else "google_id = ?")
                values.append(google_id)
            if profile_picture_url is not None:
                updates.append("profile_picture_url = %s" if self.use_postgres else "profile_picture_url = ?")
                values.append(profile_picture_url)
            
            # Always update last_login
            updates.append("last_login = CURRENT_TIMESTAMP")
            
            if updates:
                values.append(email)
                update_clause = ", ".join(updates)
                if self.use_postgres:
                    cursor.execute(f"UPDATE users SET {update_clause} WHERE email = %s", tuple(values))
                else:
                    cursor.execute(f"UPDATE users SET {update_clause} WHERE email = ?", tuple(values))
                conn.commit()
                return True
            return False
        except Exception as e:
            print(f"Error updating user profile: {e}")
            if conn:
                conn.rollback()
            return False
        finally:
            if conn:
                conn.close()
    
    def get_user_conversations(self, email: str) -> List[str]:
        """Get all conversation IDs for a user by querying conversations table"""
        conn = None
        try:
            conn = self._get_connection()
            cursor = conn.cursor()
            
            if self.use_postgres:
                cursor.execute("SELECT conversation_id FROM conversations WHERE user_email = %s ORDER BY updated_at DESC", (email,))
            else:
                cursor.execute("SELECT conversation_id FROM conversations WHERE user_email = ? ORDER BY updated_at DESC", (email,))
            
            results = cursor.fetchall()
            
            if results:
                # Extract conversation IDs from results
                if self.use_postgres:
                    return [row[0] for row in results]
                else:
                    return [row[0] for row in results]
            return []
        except Exception as e:
            print(f"Error getting user conversations: {e}")
            return []
        finally:
            if conn:
                conn.close()
    
    def create_conversation(self, email: str, conversation_id: str) -> bool:
        """Create a new conversation"""
        conn = None
        try:
            conn = self._get_connection()
            cursor = conn.cursor()
            
            # Create conversation directly in conversations table
            if self.use_postgres:
                cursor.execute(
                    "INSERT INTO conversations (conversation_id, user_email, messages) VALUES (%s, %s, %s)",
                    (conversation_id, email, json.dumps([]))
                )
            else:
                cursor.execute(
                    "INSERT INTO conversations (conversation_id, user_email, messages) VALUES (?, ?, ?)",
                    (conversation_id, email, json.dumps([]))
                )
            
            conn.commit()
            return True
        except Exception as e:
            if conn:
                conn.rollback()
            print(f"Error creating conversation: {e}")
            return False
        finally:
            if conn:
                conn.close()
    
    def get_conversation(self, conversation_id: str) -> Optional[Dict]:
        """Get conversation data"""
        conn = None
        try:
            conn = self._get_connection()
            cursor = conn.cursor()
            
            if self.use_postgres:
                cursor.execute(
                    "SELECT user_email, messages, current_quality_score, current_feedback, message_scores FROM conversations WHERE conversation_id = %s",
                    (conversation_id,)
                )
            else:
                cursor.execute(
                    "SELECT user_email, messages, current_quality_score, current_feedback, message_scores FROM conversations WHERE conversation_id = ?",
                    (conversation_id,)
                )
            
            result = cursor.fetchone()
            
            if result:
                message_scores = []
                if len(result) > 4 and result[4]:
                    try:
                        message_scores = json.loads(result[4])
                    except json.JSONDecodeError:
                        message_scores = []
                
                # Deserialize feedback if it's a JSON string
                feedback = None
                if len(result) > 3 and result[3]:
                    try:
                        feedback = json.loads(result[3])
                    except (json.JSONDecodeError, TypeError):
                        # If it's not JSON, treat it as a plain string (backward compatibility)
                        feedback = result[3]
                
                return {
                    'conversation_id': conversation_id,
                    'user_email': result[0],
                    'messages': json.loads(result[1]),
                    'quality_score': result[2] if result[2] is not None else None,
                    'feedback': feedback,
                    'message_scores': message_scores
                }
            return None
        except Exception as e:
            print(f"Error getting conversation: {e}")
            return None
        finally:
            if conn:
                conn.close()
    
    def update_conversation(self, conversation_id: str, messages: List[Dict], quality_score: float, message_scores: List[float] = None, feedback: str = None):
        """Update conversation with new messages, quality score, and feedback"""
        conn = None
        try:
            conn = self._get_connection()
            cursor = conn.cursor()
            
            # Handle message scores
            scores_json = json.dumps(message_scores) if message_scores else None
            
            if self.use_postgres:
                cursor.execute(
                    "UPDATE conversations SET messages = %s, current_quality_score = %s, current_feedback = %s, message_scores = %s, updated_at = CURRENT_TIMESTAMP WHERE conversation_id = %s",
                    (json.dumps(messages), quality_score, feedback, scores_json, conversation_id)
                )
            else:
                cursor.execute(
                    "UPDATE conversations SET messages = ?, current_quality_score = ?, current_feedback = ?, message_scores = ?, updated_at = CURRENT_TIMESTAMP WHERE conversation_id = ?",
                    (json.dumps(messages), quality_score, feedback, scores_json, conversation_id)
                )
            
            conn.commit()
        except Exception as e:
            print(f"Error updating conversation: {e}")
            if conn:
                conn.rollback()
        finally:
            if conn:
                conn.close()
    
    def get_conversation_summary(self, conversation_id: str) -> Optional[Dict]:
        """Get conversation summary for the sidebar"""
        conn = None
        try:
            conn = self._get_connection()
            cursor = conn.cursor()
            
            if self.use_postgres:
                cursor.execute(
                    "SELECT user_email, messages, created_at, updated_at FROM conversations WHERE conversation_id = %s",
                    (conversation_id,)
                )
            else:
                cursor.execute(
                    "SELECT user_email, messages, created_at, updated_at FROM conversations WHERE conversation_id = ?",
                    (conversation_id,)
                )
            
            result = cursor.fetchone()
            
            if result:
                messages = json.loads(result[1])
                first_message = messages[0]['content'] if messages else "New conversation"
                return {
                    'conversation_id': conversation_id,
                    'user_email': result[0],
                    'title': first_message[:50] + "..." if len(first_message) > 50 else first_message,
                    'created_at': str(result[2]) if result[2] else None,
                    'updated_at': str(result[3]) if result[3] else None,
                    'message_count': len(messages)
                }
            return None
        except Exception as e:
            print(f"Error getting conversation summary: {e}")
            return None
        finally:
            if conn:
                conn.close()
