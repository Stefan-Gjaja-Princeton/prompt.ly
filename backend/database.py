# IMPORTANT NOTE: This was generated by Cursor to set up and manage the overhead
# operations of the database.
import os
import json
from datetime import datetime
from typing import List, Dict, Optional
from config import Config

# Determine which database to use based on DATABASE_URL
DATABASE_URL = os.getenv('DATABASE_URL') or Config.DATABASE_URL

# PostgreSQL support (Render may use postgres:// or postgresql://)
USE_POSTGRES = DATABASE_URL and (DATABASE_URL.startswith('postgresql://') or DATABASE_URL.startswith('postgres://'))

if USE_POSTGRES:
    try:
        import psycopg2
        from psycopg2.extras import RealDictCursor
        import psycopg2.pool
        print("Using PostgreSQL database")
    except ImportError:
        print("WARNING: psycopg2 not installed. Install with: pip install psycopg2-binary")
        USE_POSTGRES = False

# SQLite fallback - but on render version won't fall back
if not USE_POSTGRES:
    import sqlite3
    print("Using SQLite database")

class Database:
    def __init__(self, db_path: str = "promptly.db"):
        self.use_postgres = USE_POSTGRES
        self.db_path = db_path
        self.database_url = DATABASE_URL
        
        if self.use_postgres:
            self._init_postgres()
        else:
            self.clear_locks()
        
        self.init_database()
    
    def _init_postgres(self):
        """Initialize PostgreSQL connection pool"""
        try:
            import psycopg2
            from psycopg2 import pool
            
            # Create connection pool with reasonable defaults
            # minconn=2: minimum 2 connections always available
            # maxconn=10: maximum 10 connections (adjust based on your needs)
            self.conn_pool = psycopg2.pool.ThreadedConnectionPool(
                minconn=2,
                maxconn=10,
                dsn=self.database_url,
                connect_timeout=10
            )
            print(f"PostgreSQL connection pool initialized (2-10 connections)")
        except Exception as e:
            print(f"Error initializing PostgreSQL connection pool: {e}")
            print("Falling back to direct connections")
            self.conn_pool = None
            # Don't disable PostgreSQL, just use direct connections as fallback
    
    def _get_connection(self):
        """Get database connection (PostgreSQL or SQLite)"""
        if self.use_postgres:
            import psycopg2
            
            # Use connection pool if available, otherwise fall back to direct connection
            if self.conn_pool:
                try:
                    conn = self.conn_pool.getconn()
                    if conn:
                        conn.autocommit = False
                        return conn
                except Exception as e:
                    print(f"Warning: Failed to get connection from pool: {e}")
                    print("Falling back to direct connection")
            
            # Fallback to direct connection if pool is unavailable
            conn = psycopg2.connect(
                self.database_url,
                connect_timeout=10
            )
            conn.autocommit = False
            return conn
        else:
            conn = sqlite3.connect(self.db_path, timeout=30.0)
            conn.execute("PRAGMA journal_mode=WAL")
            return conn
    
    def _close_connection(self, conn):
        """Close or return connection to pool depending on database type"""
        if not conn:
            return
        
        if self.use_postgres and self.conn_pool:
            # Return to connection pool
            try:
                self.conn_pool.putconn(conn)
            except Exception as e:
                print(f"Warning: Failed to return connection to pool: {e}")
                # If returning fails, close the connection
                try:
                    self._close_connection(conn)
                except:
                    pass
        else:
            # Close connection directly (SQLite or PostgreSQL without pool)
            try:
                self._close_connection(conn)
            except:
                pass
    
    # deprecate this, not used any more
    def _execute_query(self, query: str, params: tuple = None, fetch_one: bool = False, fetch_all: bool = False):
        """Execute a query and return results"""
        conn = None
        try:
            conn = self._get_connection()
            cursor = conn.cursor()
            
            # Convert SQLite-style ? placeholders to PostgreSQL %s if needed
            if self.use_postgres and '?' in query:
                query = query.replace('?', '%s')
            
            if params:
                cursor.execute(query, params)
            else:
                cursor.execute(query)
            
            if fetch_one:
                result = cursor.fetchone()
                if self.use_postgres and result:
                    # Convert tuple to list for consistency
                    result = list(result)
                return result
            elif fetch_all:
                results = cursor.fetchall()
                if self.use_postgres:
                    # Convert tuples to lists
                    results = [list(r) for r in results]
                return results
            
            conn.commit()
            return None
        except Exception as e:
            if conn:
                conn.rollback()
            print(f"Error executing query: {e}")
            raise
        finally:
            if conn:
                self._close_connection(conn)
    
    def clear_locks(self):
        """Clear any existing database locks (SQLite only)"""
        if self.use_postgres:
            return
        
        try:
            import os
            wal_file = f"{self.db_path}-wal"
            shm_file = f"{self.db_path}-shm"
            
            if os.path.exists(wal_file):
                os.remove(wal_file)
            if os.path.exists(shm_file):
                os.remove(shm_file)
        except Exception as e:
            print(f"Warning: Could not clear database locks: {e}")
    
    # makes the database that I use
    def init_database(self):
        """Initialize the database with required tables"""
        conn = None
        try:
            conn = self._get_connection()
            cursor = conn.cursor()
            
            if self.use_postgres:
                # PostgreSQL table creation
                # Create users table
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS users (
                        email VARCHAR(255) PRIMARY KEY,
                        first_name VARCHAR(255),
                        last_name VARCHAR(255),
                        google_id VARCHAR(255),
                        profile_picture_url TEXT,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        last_login TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                    )
                ''')
                
                # Create conversations table
                # can just use this to fetch the conversations
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS conversations (
                        conversation_id VARCHAR(255) PRIMARY KEY,
                        user_email VARCHAR(255),
                        messages TEXT,
                        current_quality_score REAL DEFAULT NULL,
                        current_feedback TEXT DEFAULT NULL,
                        message_scores TEXT,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        FOREIGN KEY (user_email) REFERENCES users (email) ON DELETE CASCADE
                    )
                ''')
            else:
                # SQLite table creation (original)
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS users (
                        email TEXT PRIMARY KEY,
                        first_name TEXT,
                        last_name TEXT,
                        google_id TEXT,
                        profile_picture_url TEXT,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        last_login TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                    )
                ''')
                
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS conversations (
                        conversation_id TEXT PRIMARY KEY,
                        user_email TEXT,
                        messages TEXT,
                        current_quality_score REAL DEFAULT NULL,
                        current_feedback TEXT DEFAULT NULL,
                        message_scores TEXT,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        FOREIGN KEY (user_email) REFERENCES users (email)
                    )
                ''')
            
            # Add current_feedback column if it doesn't exist (for existing databases) - was when I was porting over
            if self.use_postgres:
                # PostgreSQL: Check if column exists
                cursor.execute('''
                    SELECT column_name 
                    FROM information_schema.columns 
                    WHERE table_name='conversations' AND column_name='current_feedback'
                ''')
                if not cursor.fetchone():
                    cursor.execute('ALTER TABLE conversations ADD COLUMN current_feedback TEXT DEFAULT NULL')
            else:
                # SQLite: Try to add column (will fail silently if exists)
                try:
                    cursor.execute('ALTER TABLE conversations ADD COLUMN current_feedback TEXT DEFAULT NULL')
                except sqlite3.OperationalError:
                    pass  # Column already exists
            
            # Add title column if it doesn't exist
            if self.use_postgres:
                # PostgreSQL: Check if column exists
                cursor.execute('''
                    SELECT column_name 
                    FROM information_schema.columns 
                    WHERE table_name='conversations' AND column_name='title'
                ''')
                if not cursor.fetchone():
                    cursor.execute('ALTER TABLE conversations ADD COLUMN title TEXT DEFAULT NULL')
            else:
                # SQLite: Try to add column (will fail silently if exists)
                try:
                    cursor.execute('ALTER TABLE conversations ADD COLUMN title TEXT DEFAULT NULL')
                except sqlite3.OperationalError:
                    pass  # Column already exists
            
            # Add message_count column if it doesn't exist (for performance optimization)
            if self.use_postgres:
                cursor.execute('''
                    SELECT column_name 
                    FROM information_schema.columns 
                    WHERE table_name='conversations' AND column_name='message_count'
                ''')
                if not cursor.fetchone():
                    cursor.execute('ALTER TABLE conversations ADD COLUMN message_count INTEGER DEFAULT 0')
            else:
                # SQLite: Try to add column (will fail silently if exists)
                try:
                    cursor.execute('ALTER TABLE conversations ADD COLUMN message_count INTEGER DEFAULT 0')
                except sqlite3.OperationalError:
                    pass  # Column already exists
            
            # Add indexes for performance (safe to run multiple times with IF NOT EXISTS)
            if self.use_postgres:
                cursor.execute('''
                    CREATE INDEX IF NOT EXISTS idx_conversations_user_email 
                    ON conversations(user_email)
                ''')
                cursor.execute('''
                    CREATE INDEX IF NOT EXISTS idx_conversations_updated_at 
                    ON conversations(updated_at DESC)
                ''')
            else:
                # SQLite: Check if index exists before creating
                cursor.execute("SELECT name FROM sqlite_master WHERE type='index' AND name='idx_conversations_user_email'")
                if not cursor.fetchone():
                    cursor.execute('CREATE INDEX idx_conversations_user_email ON conversations(user_email)')
                
                cursor.execute("SELECT name FROM sqlite_master WHERE type='index' AND name='idx_conversations_updated_at'")
                if not cursor.fetchone():
                    cursor.execute('CREATE INDEX idx_conversations_updated_at ON conversations(updated_at DESC)')
            
            conn.commit()
        except Exception as e:
            print(f"Error initializing database: {e}")
            if conn:
                conn.rollback()
        finally:
            if conn:
                self._close_connection(conn)
    
    def create_user(self, email: str, first_name: str = None, last_name: str = None, google_id: str = None, profile_picture_url: str = None) -> bool:
        """Create a new user (doesn't do anything for existing users)"""
        conn = None
        try:
            conn = self._get_connection()
            cursor = conn.cursor()
            
            if self.use_postgres:
                cursor.execute(
                    "INSERT INTO users (email, first_name, last_name, google_id, profile_picture_url) VALUES (%s, %s, %s, %s, %s) ON CONFLICT (email) DO NOTHING",
                    (email, first_name, last_name, google_id, profile_picture_url)
                )
            else:
                cursor.execute(
                    "INSERT OR IGNORE INTO users (email, first_name, last_name, google_id, profile_picture_url) VALUES (?, ?, ?, ?, ?)",
                    (email, first_name, last_name, google_id, profile_picture_url)
                )
            
            conn.commit()
            return True
        except Exception as e:
            print(f"Error creating user: {e}")
            if conn:
                conn.rollback()
            return False
        finally:
            if conn:
                self._close_connection(conn)
    
    def get_user_by_email(self, email: str) -> Optional[Dict]:
        """Fetch a user record by email"""
        conn = None
        try:
            conn = self._get_connection()
            cursor = conn.cursor()
            
            if self.use_postgres:
                cursor.execute(
                    "SELECT email, first_name, last_name, google_id, profile_picture_url, created_at, last_login FROM users WHERE email = %s",
                    (email,)
                )
            else:
                cursor.execute(
                    "SELECT email, first_name, last_name, google_id, profile_picture_url, created_at, last_login FROM users WHERE email = ?",
                    (email,)
                )
            
            row = cursor.fetchone()
            if not row:
                return None
            
            return {
                'email': row[0],
                'first_name': row[1],
                'last_name': row[2],
                'google_id': row[3],
                'profile_picture_url': row[4],
                'created_at': str(row[5]) if row[5] else None,
                'last_login': str(row[6]) if row[6] else None,
            }
        except Exception as e:
            print(f"Error getting user by email: {e}")
            return None
        finally:
            if conn:
                self._close_connection(conn)
    
    def update_user_login(self, email: str) -> None:
        """Update last_login when a user signs in"""
        conn = None
        try:
            conn = self._get_connection()
            cursor = conn.cursor()
            
            if self.use_postgres:
                cursor.execute("UPDATE users SET last_login = CURRENT_TIMESTAMP WHERE email = %s", (email,))
            else:
                cursor.execute("UPDATE users SET last_login = CURRENT_TIMESTAMP WHERE email = ?", (email,))
            
            conn.commit()
        except Exception as e:
            print(f"Error updating user last_login: {e}")
            if conn:
                conn.rollback()
        finally:
            if conn:
                self._close_connection(conn)
    
    def update_user_profile(self, email: str, first_name: str = None, last_name: str = None, google_id: str = None, profile_picture_url: str = None) -> bool:
        """Update user profile information"""
        conn = None
        try:
            conn = self._get_connection()
            cursor = conn.cursor()
            
            # Build update query dynamically based on what's provided
            updates = []
            values = []
            
            if first_name is not None:
                updates.append("first_name = %s" if self.use_postgres else "first_name = ?")
                values.append(first_name)
            if last_name is not None:
                updates.append("last_name = %s" if self.use_postgres else "last_name = ?")
                values.append(last_name)
            if google_id is not None:
                updates.append("google_id = %s" if self.use_postgres else "google_id = ?")
                values.append(google_id)
            if profile_picture_url is not None:
                updates.append("profile_picture_url = %s" if self.use_postgres else "profile_picture_url = ?")
                values.append(profile_picture_url)
            
            # Always update last_login
            updates.append("last_login = CURRENT_TIMESTAMP")
            
            if updates:
                values.append(email)
                update_clause = ", ".join(updates)
                if self.use_postgres:
                    cursor.execute(f"UPDATE users SET {update_clause} WHERE email = %s", tuple(values))
                else:
                    cursor.execute(f"UPDATE users SET {update_clause} WHERE email = ?", tuple(values))
                conn.commit()
                return True
            return False
        except Exception as e:
            print(f"Error updating user profile: {e}")
            if conn:
                conn.rollback()
            return False
        finally:
            if conn:
                self._close_connection(conn)
    
    def get_user_conversations(self, email: str) -> List[str]:
        """Get all conversation IDs for a user by querying conversations table"""
        conn = None
        try:
            conn = self._get_connection()
            cursor = conn.cursor()
            
            if self.use_postgres:
                cursor.execute("SELECT conversation_id FROM conversations WHERE user_email = %s ORDER BY updated_at DESC", (email,))
            else:
                cursor.execute("SELECT conversation_id FROM conversations WHERE user_email = ? ORDER BY updated_at DESC", (email,))
            
            results = cursor.fetchall()
            
            if results:
                # Extract conversation IDs from results
                if self.use_postgres:
                    return [row[0] for row in results]
                else:
                    return [row[0] for row in results]
            return []
        except Exception as e:
            print(f"Error getting user conversations: {e}")
            return []
        finally:
            if conn:
                self._close_connection(conn)
    
    def create_conversation(self, email: str, conversation_id: str) -> bool:
        """Create a new conversation"""
        conn = None
        try:
            conn = self._get_connection()
            cursor = conn.cursor()
            
            # Create conversation directly in conversations table
            # Check if message_count column exists first
            has_message_count = False
            if self.use_postgres:
                try:
                    cursor.execute('''
                        SELECT column_name 
                        FROM information_schema.columns 
                        WHERE LOWER(table_name)=LOWER('conversations') AND column_name='message_count'
                    ''')
                    has_message_count = cursor.fetchone() is not None
                except:
                    has_message_count = False
            else:
                cursor.execute("PRAGMA table_info(conversations)")
                columns = cursor.fetchall()
                has_message_count = any(col[1] == 'message_count' for col in columns)
            
            if has_message_count:
                if self.use_postgres:
                    cursor.execute(
                        "INSERT INTO conversations (conversation_id, user_email, messages, message_count) VALUES (%s, %s, %s, %s)",
                        (conversation_id, email, json.dumps([]), 0)
                    )
                else:
                    cursor.execute(
                        "INSERT INTO conversations (conversation_id, user_email, messages, message_count) VALUES (?, ?, ?, ?)",
                        (conversation_id, email, json.dumps([]), 0)
                    )
            else:
                if self.use_postgres:
                    cursor.execute(
                        "INSERT INTO conversations (conversation_id, user_email, messages) VALUES (%s, %s, %s)",
                        (conversation_id, email, json.dumps([]))
                    )
                else:
                    cursor.execute(
                        "INSERT INTO conversations (conversation_id, user_email, messages) VALUES (?, ?, ?)",
                        (conversation_id, email, json.dumps([]))
                    )
            
            conn.commit()
            return True
        except Exception as e:
            if conn:
                conn.rollback()
            print(f"Error creating conversation: {e}")
            return False
        finally:
            if conn:
                self._close_connection(conn)
    
    def get_conversation(self, conversation_id: str, limit_messages: int = None) -> Optional[Dict]:
        """Get conversation data, optionally limiting to last N messages"""
        conn = None
        try:
            conn = self._get_connection()
            cursor = conn.cursor()
            
            if self.use_postgres:
                cursor.execute(
                    "SELECT user_email, messages, current_quality_score, current_feedback, message_scores, title FROM conversations WHERE conversation_id = %s",
                    (conversation_id,)
                )
            else:
                cursor.execute(
                    "SELECT user_email, messages, current_quality_score, current_feedback, message_scores, title FROM conversations WHERE conversation_id = ?",
                    (conversation_id,)
                )
            
            result = cursor.fetchone()
            
            if result:
                message_scores = []
                if len(result) > 4 and result[4]:
                    try:
                        message_scores = json.loads(result[4])
                    except json.JSONDecodeError:
                        message_scores = []
                
                # Deserialize feedback if it's a JSON string
                feedback = None
                if len(result) > 3 and result[3]:
                    try:
                        feedback = json.loads(result[3])
                    except (json.JSONDecodeError, TypeError):
                        # If it's not JSON, treat it as a plain string (backward compatibility)
                        feedback = result[3]
                
                # Parse messages
                all_messages = json.loads(result[1])
                
                # If limit_messages is specified, return only the last N messages
                if limit_messages is not None and limit_messages > 0 and len(all_messages) > limit_messages:
                    messages = all_messages[-limit_messages:]
                else:
                    messages = all_messages
                
                return {
                    'conversation_id': conversation_id,
                    'user_email': result[0],
                    'messages': messages,
                    'quality_score': result[2] if result[2] is not None else None,
                    'feedback': feedback,
                    'message_scores': message_scores,
                    'title': result[5] if len(result) > 5 else None,
                    'total_message_count': len(all_messages),
                    'has_more_messages': limit_messages is not None and len(all_messages) > limit_messages
                }
            return None
        except Exception as e:
            print(f"Error getting conversation: {e}")
            import traceback
            print(traceback.format_exc())
            return None
        finally:
            if conn:
                self._close_connection(conn)
    
    def update_conversation(self, conversation_id: str, messages: List[Dict], quality_score: float, message_scores: List[float] = None, feedback: str = None, title: str = None):
        """Update conversation with new messages, quality score, feedback, and optionally title"""
        conn = None
        try:
            conn = self._get_connection()
            cursor = conn.cursor()
            
            # Check if message_count column exists (for backward compatibility)
            has_message_count = False
            if self.use_postgres:
                try:
                    cursor.execute('''
                        SELECT column_name 
                        FROM information_schema.columns 
                        WHERE LOWER(table_name)=LOWER('conversations') AND column_name='message_count'
                    ''')
                    has_message_count = cursor.fetchone() is not None
                except Exception as e:
                    print(f"Warning: Could not check for message_count column: {e}")
                    has_message_count = False
            else:
                cursor.execute("PRAGMA table_info(conversations)")
                columns = cursor.fetchall()
                has_message_count = any(col[1] == 'message_count' for col in columns)
            
            # Handle message scores
            scores_json = json.dumps(message_scores) if message_scores else None
            message_count = len(messages) if messages else 0
            
            # Build update query - only update title if provided, and message_count if column exists
            if title is not None:
                if has_message_count:
                    if self.use_postgres:
                        cursor.execute(
                            "UPDATE conversations SET messages = %s, current_quality_score = %s, current_feedback = %s, message_scores = %s, title = %s, message_count = %s, updated_at = CURRENT_TIMESTAMP WHERE conversation_id = %s",
                            (json.dumps(messages), quality_score, feedback, scores_json, title, message_count, conversation_id)
                        )
                    else:
                        cursor.execute(
                            "UPDATE conversations SET messages = ?, current_quality_score = ?, current_feedback = ?, message_scores = ?, title = ?, message_count = ?, updated_at = CURRENT_TIMESTAMP WHERE conversation_id = ?",
                            (json.dumps(messages), quality_score, feedback, scores_json, title, message_count, conversation_id)
                        )
                else:
                    if self.use_postgres:
                        cursor.execute(
                            "UPDATE conversations SET messages = %s, current_quality_score = %s, current_feedback = %s, message_scores = %s, title = %s, updated_at = CURRENT_TIMESTAMP WHERE conversation_id = %s",
                            (json.dumps(messages), quality_score, feedback, scores_json, title, conversation_id)
                        )
                    else:
                        cursor.execute(
                            "UPDATE conversations SET messages = ?, current_quality_score = ?, current_feedback = ?, message_scores = ?, title = ?, updated_at = CURRENT_TIMESTAMP WHERE conversation_id = ?",
                            (json.dumps(messages), quality_score, feedback, scores_json, title, conversation_id)
                        )
            else:
                if has_message_count:
                    if self.use_postgres:
                        cursor.execute(
                            "UPDATE conversations SET messages = %s, current_quality_score = %s, current_feedback = %s, message_scores = %s, message_count = %s, updated_at = CURRENT_TIMESTAMP WHERE conversation_id = %s",
                            (json.dumps(messages), quality_score, feedback, scores_json, message_count, conversation_id)
                        )
                    else:
                        cursor.execute(
                            "UPDATE conversations SET messages = ?, current_quality_score = ?, current_feedback = ?, message_scores = ?, message_count = ?, updated_at = CURRENT_TIMESTAMP WHERE conversation_id = ?",
                            (json.dumps(messages), quality_score, feedback, scores_json, message_count, conversation_id)
                        )
                else:
                    if self.use_postgres:
                        cursor.execute(
                            "UPDATE conversations SET messages = %s, current_quality_score = %s, current_feedback = %s, message_scores = %s, updated_at = CURRENT_TIMESTAMP WHERE conversation_id = %s",
                            (json.dumps(messages), quality_score, feedback, scores_json, conversation_id)
                        )
                    else:
                        cursor.execute(
                            "UPDATE conversations SET messages = ?, current_quality_score = ?, current_feedback = ?, message_scores = ?, updated_at = CURRENT_TIMESTAMP WHERE conversation_id = ?",
                            (json.dumps(messages), quality_score, feedback, scores_json, conversation_id)
                        )
            
            conn.commit()
        except Exception as e:
            print(f"Error updating conversation: {e}")
            import traceback
            print(traceback.format_exc())
            if conn:
                conn.rollback()
        finally:
            if conn:
                self._close_connection(conn)
    
    def get_conversation_summary(self, conversation_id: str) -> Optional[Dict]:
        """Get conversation summary for the sidebar"""
        conn = None
        try:
            conn = self._get_connection()
            cursor = conn.cursor()
            
            # Check if message_count column exists (for backward compatibility)
            has_message_count = False
            if self.use_postgres:
                try:
                    cursor.execute('''
                        SELECT column_name 
                        FROM information_schema.columns 
                        WHERE LOWER(table_name)=LOWER('conversations') AND column_name='message_count'
                    ''')
                    has_message_count = cursor.fetchone() is not None
                except Exception as e:
                    print(f"Warning: Could not check for message_count column: {e}")
                    has_message_count = False
            else:
                cursor.execute("PRAGMA table_info(conversations)")
                columns = cursor.fetchall()
                has_message_count = any(col[1] == 'message_count' for col in columns)
            
            if self.use_postgres:
                if has_message_count:
                    cursor.execute(
                        "SELECT user_email, title, created_at, updated_at, message_count FROM conversations WHERE conversation_id = %s",
                        (conversation_id,)
                    )
                else:
                    cursor.execute(
                        "SELECT user_email, messages, title, created_at, updated_at FROM conversations WHERE conversation_id = %s",
                        (conversation_id,)
                    )
            else:
                if has_message_count:
                    cursor.execute(
                        "SELECT user_email, title, created_at, updated_at, message_count FROM conversations WHERE conversation_id = ?",
                        (conversation_id,)
                    )
                else:
                    cursor.execute(
                        "SELECT user_email, messages, title, created_at, updated_at FROM conversations WHERE conversation_id = ?",
                        (conversation_id,)
                    )
            
            result = cursor.fetchone()
            
            if result:
                if has_message_count:
                    # Use message_count column
                    message_count = result[4] if result[4] is not None else 0
                    return {
                        'conversation_id': conversation_id,
                        'user_email': result[0],
                        'title': result[1],
                        'created_at': str(result[2]) if result[2] else None,
                        'updated_at': str(result[3]) if result[3] else None,
                        'message_count': message_count
                    }
                else:
                    # Parse messages JSON to count
                    messages = json.loads(result[1]) if result[1] else []
                    return {
                        'conversation_id': conversation_id,
                        'user_email': result[0],
                        'title': result[2],
                        'created_at': str(result[3]) if result[3] else None,
                        'updated_at': str(result[4]) if result[4] else None,
                        'message_count': len(messages)
                    }
            return None
        except Exception as e:
            print(f"Error getting conversation summary: {e}")
            import traceback
            print(traceback.format_exc())
            return None
        finally:
            if conn:
                self._close_connection(conn)
    
    def get_user_conversation_summaries(self, email: str, limit: int = None, offset: int = 0) -> List[Dict]:
        """Get all conversation summaries for a user in a single query (fixes N+1 problem)"""
        conn = None
        try:
            conn = self._get_connection()
            cursor = conn.cursor()
            
            # Check if message_count column exists (for backward compatibility)
            has_message_count = False
            if self.use_postgres:
                try:
                    cursor.execute('''
                        SELECT column_name 
                        FROM information_schema.columns 
                        WHERE LOWER(table_name)=LOWER('conversations') AND column_name='message_count'
                    ''')
                    has_message_count = cursor.fetchone() is not None
                except Exception as e:
                    print(f"Warning: Could not check for message_count column: {e}")
                    has_message_count = False
            else:
                cursor.execute("PRAGMA table_info(conversations)")
                columns = cursor.fetchall()
                has_message_count = any(col[1] == 'message_count' for col in columns)
            
            # Build query based on whether message_count column exists
            if self.use_postgres:
                if has_message_count:
                    base_query = """
                        SELECT conversation_id, user_email, title, created_at, updated_at, message_count 
                        FROM conversations 
                        WHERE user_email = %s 
                        ORDER BY updated_at DESC
                    """
                else:
                    # Fallback: parse messages JSON to count
                    base_query = """
                        SELECT conversation_id, user_email, messages, title, created_at, updated_at 
                        FROM conversations 
                        WHERE user_email = %s 
                        ORDER BY updated_at DESC
                    """
                if limit is not None:
                    query = base_query + " LIMIT %s OFFSET %s"
                    cursor.execute(query, (email, limit, offset))
                else:
                    cursor.execute(base_query, (email,))
            else:
                if has_message_count:
                    base_query = """
                        SELECT conversation_id, user_email, title, created_at, updated_at, message_count 
                        FROM conversations 
                        WHERE user_email = ? 
                        ORDER BY updated_at DESC
                    """
                else:
                    # Fallback: parse messages JSON to count
                    base_query = """
                        SELECT conversation_id, user_email, messages, title, created_at, updated_at 
                        FROM conversations 
                        WHERE user_email = ? 
                        ORDER BY updated_at DESC
                    """
                if limit is not None:
                    query = base_query + " LIMIT ? OFFSET ?"
                    cursor.execute(query, (email, limit, offset))
                else:
                    cursor.execute(base_query, (email,))
            
            results = cursor.fetchall()
            conversations = []
            
            for row in results:
                try:
                    if has_message_count:
                        # Use message_count column
                        conversations.append({
                            'conversation_id': row[0],
                            'user_email': row[1],
                            'title': row[2],  # title
                            'created_at': str(row[3]) if row[3] else None,
                            'updated_at': str(row[4]) if row[4] else None,
                            'message_count': row[5] if row[5] is not None else 0
                        })
                    else:
                        # Parse messages JSON to count
                        messages = json.loads(row[2]) if row[2] else []
                        conversations.append({
                            'conversation_id': row[0],
                            'user_email': row[1],
                            'title': row[3],  # title
                            'created_at': str(row[4]) if row[4] else None,
                            'updated_at': str(row[5]) if row[5] else None,
                            'message_count': len(messages)
                        })
                except (IndexError, TypeError, json.JSONDecodeError) as e:
                    print(f"Error parsing conversation {row[0] if row else 'unknown'}: {e}")
                    # Skip malformed conversations
                    continue
            
            return conversations
        except Exception as e:
            print(f"Error getting user conversation summaries: {e}")
            import traceback
            print(traceback.format_exc())
            return []
        finally:
            if conn:
                self._close_connection(conn)