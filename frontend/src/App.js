// IMPORTANT NOTE: This and the associated css file were generated by Cursor and sets up the main functions of the application.*/
import React, {
  useState,
  useEffect,
  useCallback,
  useMemo,
  useRef,
} from "react";
import { useAuth0 } from "@auth0/auth0-react";
import "./App.css";
import ConversationList from "./components/ConversationList";
import ChatWindow from "./components/ChatWindow";
import FeedbackPanel from "./components/FeedbackPanel";
import UserHeader from "./components/UserHeader";
import LoginPage from "./components/LoginPage";
import { createApiService } from "./services/apiService";

function App() {
  const { isAuthenticated, isLoading, getAccessTokenSilently } = useAuth0();

  // Memoize apiService to prevent recreation on every render
  const apiService = useMemo(
    () => createApiService(getAccessTokenSilently),
    [getAccessTokenSilently]
  );

  // state management
  const [conversations, setConversations] = useState([]);
  const [conversationsLoading, setConversationsLoading] = useState(false);
  const [currentConversationId, setCurrentConversationId] = useState(null);
  const [messages, setMessages] = useState([]);
  const [qualityScore, setQualityScore] = useState(null);
  const [feedback, setFeedback] = useState(null);
  const [isTerse, setIsTerse] = useState(false);
  const [loading, setLoading] = useState(false);
  const [feedbackLoading, setFeedbackLoading] = useState(false);

  // Use refs to store latest callbacks without triggering re-renders
  const loadConversationsRef = useRef();
  const loadConversationRef = useRef();
  const isSendingMessageRef = useRef(false); // Track if we're currently sending a message

  // gets all the convos
  const loadConversations = useCallback(async () => {
    if (!isAuthenticated) return;
    setConversationsLoading(true);
    try {
      const data = await apiService.getConversations();
      setConversations(data || []); // Ensure we always have an array
    } catch (error) {
      console.error("Error loading conversations:", error);
      // Don't clear conversations on error - keep existing ones
      // setConversations([]); // Removed - don't clear on error
    } finally {
      setConversationsLoading(false);
    }
  }, [isAuthenticated, apiService]);

  loadConversationsRef.current = loadConversations;

  // gets the specific convos when conversation ID changes
  const loadConversation = useCallback(
    async (conversationId) => {
      if (!conversationId) return;
      try {
        const data = await apiService.getConversation(conversationId);
        setMessages(data.messages || []);
        setQualityScore(data.quality_score);
        setFeedback(data.feedback || null); // Load feedback from conversation
        setIsTerse(data.quality_score !== null && data.quality_score <= 5.0);
        // Scroll is handled by useEffect in ChatWindow when messages change
      } catch (error) {
        console.error("Error loading conversation:", error);
      }
    },
    [apiService]
  );

  loadConversationRef.current = loadConversation;

  // Track if we've loaded conversations initially
  const hasLoadedConversations = useRef(false);

  // Load conversations only once when authenticated
  useEffect(() => {
    if (isAuthenticated && !hasLoadedConversations.current) {
      hasLoadedConversations.current = true;
      loadConversationsRef.current();
    }
  }, [isAuthenticated]);

  // Load conversation when currentConversationId changes
  // But don't load if we're currently sending a message (to preserve user message) - in response to user feedback
  useEffect(() => {
    if (
      currentConversationId &&
      loadConversationRef.current &&
      !isSendingMessageRef.current
    ) {
      loadConversationRef.current(currentConversationId);
    }
  }, [currentConversationId]);

  // uses the apiService to make a conversation
  const createNewConversation = async () => {
    try {
      const data = await apiService.createConversation();
      // Don't add to conversations list yet - only add when first message is sent
      setCurrentConversationId(data.conversation_id);
      setMessages([]);
      setQualityScore(null);
      setFeedback(null);
      setIsTerse(false);

      return data.conversation_id;
    } catch (error) {
      console.error("Error creating conversation:", error);
      throw error;
    }
  };

  const sendMessage = async (message) => {
    // Mark that we're sending a message to prevent loadConversation from clearing messages
    isSendingMessageRef.current = true;

    // Add user message immediately to the chat FIRST (before any async operations)
    const userMessage = {
      role: "user",
      content: message,
      timestamp: new Date().toISOString(),
    };
    setMessages((prev) => [...prev, userMessage]);

    // Ensure we have a conversation to send into; create one if needed
    let activeConversationId = currentConversationId;
    // this is all if we gotta make a new convo
    if (!activeConversationId) {
      try {
        // Create conversation but don't clear messages - preserve the user message we just added
        const data = await apiService.createConversation();
        activeConversationId = data.conversation_id;
        setCurrentConversationId(data.conversation_id);
        // Don't add to conversations list yet - will be added after first message with title
        // Don't clear messages here - we already added the user message above
      } catch (e) {
        // Better error message extraction
        let errorMessage = "Failed to create conversation. ";

        if (e.response) {
          // Server responded with error
          const status = e.response.status;
          const data = e.response.data;

          if (status === 401) {
            errorMessage +=
              "Authentication failed. Please try logging out and back in.";
          } else if (status === 500) {
            errorMessage +=
              "Server error occurred. Please check if the backend is running.";
          } else if (data?.error) {
            errorMessage += data.error;
          } else {
            errorMessage += `Server returned error ${status}`;
          }
        } else if (e.request) {
          // Request made but no response - network error
          errorMessage += "Network error - unable to reach the server. ";
          errorMessage += "Please check:\n";
          errorMessage += "1. Is the backend service running?\n";
          errorMessage +=
            "2. Check the browser console (F12) for more details.\n";
          errorMessage += `3. Verify REACT_APP_API_URL is set correctly.`;
        } else {
          // Other error
          errorMessage += e.message || String(e);
        }

        console.error("Error creating conversation:", e);
        alert(errorMessage);

        // Remove the user message if conversation creation failed
        setMessages((prev) => prev.filter((msg) => msg !== userMessage));
        isSendingMessageRef.current = false;
        return;
      }
    }

    setLoading(true);
    setFeedbackLoading(true);
    try {
      // Step 1: Get feedback and score immediately
      const feedbackResponse = await apiService.sendMessage(
        activeConversationId,
        message
      );

      console.log("DEBUG: Feedback Response:", feedbackResponse);

      // Update feedback and score immediately
      setQualityScore(feedbackResponse.quality_score);
      setFeedback(feedbackResponse.feedback);
      setIsTerse(
        feedbackResponse.quality_score !== null &&
        feedbackResponse.quality_score <= 5.0
      );

      // Store title for later use when updating conversation list
      const updated_title = feedbackResponse.title;
      
      // Update conversation title in the list if it was generated (only if conversation already exists)
      if (updated_title) {
        setConversations((prev) => {
          const exists = prev.some((conv) => conv.conversation_id === activeConversationId);
          if (exists) {
            return prev.map((conv) =>
              conv.conversation_id === activeConversationId
                ? { ...conv, title: updated_title }
                : conv
            );
          }
          return prev;
        });
      }

      // Stop feedback loading immediately
      setFeedbackLoading(false);

      // Step 2: Get AI response after feedback is ready (streaming)
      // Don't add message until first chunk arrives
      const streamingMessageId = Date.now();
      let streamingMessageAdded = false;

      // Stream AI response
      let fullResponse = "";

      await apiService.getAIResponse(
        activeConversationId,
        // onChunk callback - update state immediately for each chunk
        (chunk) => {
          fullResponse += chunk;

          // Add the streaming message only when first chunk arrives
          if (!streamingMessageAdded) {
            streamingMessageAdded = true;
            const streamingMessage = {
              role: "assistant",
              content: fullResponse,
              timestamp: new Date().toISOString(),
              _streaming: true,
              _id: streamingMessageId,
            };
            setMessages((prev) => [...prev, streamingMessage]);
          } else {
            // Update state immediately - React 18 will handle batching appropriately
            setMessages((prev) => {
              const updated = prev.map((msg) =>
                msg._id === streamingMessageId
                  ? { ...msg, content: fullResponse }
                  : msg
              );
              return updated;
            });
          }
        },
        // onComplete callback
        (completeResponse) => {
          // Replace streaming message with final message
          setMessages((prev) => {
            const updated = prev.map((msg) =>
              msg._id === streamingMessageId
                ? {
                    role: "assistant",
                    content: completeResponse || fullResponse,
                    timestamp: new Date().toISOString(),
                  }
                : msg
            );
            
            // Update conversations list - update in place instead of reloading to avoid flickering
            if (isAuthenticated) {
              // Get current messages count after update - count ALL messages (user + assistant)
              const totalMessageCount = updated.length;
              
              // If this is a new conversation (not in list yet), add it
              setConversations((prevConvs) => {
                const conversationExists = prevConvs.some(
                  (conv) => conv.conversation_id === activeConversationId
                );
                
                if (!conversationExists) {
                  // Add new conversation to the list
                  // Use current timestamp - will be updated from backend on next load
                  const now = new Date().toISOString();
                  const newConversation = {
                    conversation_id: activeConversationId,
                    title: updated_title || "New Conversation",
                    created_at: now,
                    updated_at: now,
                    message_count: totalMessageCount,
                  };
                  return [newConversation, ...prevConvs];
                } else {
                  // Update existing conversation in place
                  return prevConvs.map((conv) =>
                    conv.conversation_id === activeConversationId
                      ? {
                          ...conv,
                          title: updated_title || conv.title,
                          updated_at: new Date().toISOString(),
                          message_count: totalMessageCount,
                        }
                      : conv
                  );
                }
              });
            }
            
            return updated;
          });

          // Message sending is complete, allow loadConversation to run again
          isSendingMessageRef.current = false;
          setLoading(false);
        },
        // onError callback
        (errorData) => {
          console.error("Streaming error:", errorData);
          // Remove streaming message on error
          setMessages((prev) =>
            prev.filter((msg) => msg._id !== streamingMessageId)
          );

          let errorMessage = "Failed to get AI response. ";
          if (errorData.error) {
            errorMessage += errorData.error;
          } else if (errorData.details) {
            errorMessage += errorData.details;
          }

          alert(errorMessage);
          isSendingMessageRef.current = false;
          setLoading(false);
        }
      );
    } catch (error) {
      console.error("Error sending message:", error);

      // Handle different error types
      let errorMessage = "Failed to send message. ";
      if (error.response) {
        // Server responded with error
        const status = error.response.status;
        const data = error.response.data;

        if (status === 401) {
          errorMessage +=
            "Authentication failed. Please try logging out and back in.";
        } else if (status === 429) {
          errorMessage +=
            "Too many requests. Please wait a moment and try again.";
        } else if (status === 500) {
          errorMessage += "Server error occurred. Please try again.";
        } else if (status === 400 && data?.message) {
          // Use the message field if available (e.g., conversation limit reached)
          errorMessage = data.message;
        } else if (data?.error) {
          errorMessage += data.error;
        } else {
          errorMessage += `Error ${status}: ${
            error.message || "Unknown error"
          }`;
        }
      } else if (error.request) {
        // Request made but no response
        errorMessage +=
          "No response from server. Please check your connection.";
      } else {
        // Other error
        errorMessage += error.message || "Unknown error occurred.";
      }

      // Show error message to user
      alert(errorMessage);

      // Remove the user message if there was an error
      setMessages((prev) => prev.filter((msg) => msg !== userMessage));
      // Allow loadConversation to run again even on error
      isSendingMessageRef.current = false;
    } finally {
      setLoading(false);
      setFeedbackLoading(false);
    }
  };

  const selectConversation = (conversationId) => {
    setCurrentConversationId(conversationId);
  };

  if (isLoading) {
    return (
      <div className="app app-loading">
        <div className="loading-container">
          <div className="loading-spinner"></div>
        </div>
      </div>
    );
  }

  if (!isAuthenticated) {
    return <LoginPage />;
  }

  return (
    <div className="app">
      <UserHeader />
      <div className="app-container">
        <ConversationList
          conversations={conversations}
          currentConversationId={currentConversationId}
          onSelectConversation={selectConversation}
          onCreateNew={createNewConversation}
          loading={conversationsLoading}
          isNewConversation={currentConversationId !== null && messages.length === 0}
        />

        <ChatWindow
          messages={messages}
          onSendMessage={sendMessage}
          loading={loading}
          isTerse={isTerse}
          isLimitReached={
            messages.filter((msg) => msg.role === "user").length >= 20
          }
        />

        <FeedbackPanel
          qualityScore={qualityScore}
          feedback={feedback}
          isTerse={isTerse}
          loading={feedbackLoading}
        />
      </div>
    </div>
  );
}

export default App;
