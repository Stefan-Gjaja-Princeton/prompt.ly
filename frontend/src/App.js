// IMPORTANT NOTE: This and the associated css file were generated by Cursor and sets up the main functions of the application.*/
import React, {
  useState,
  useEffect,
  useCallback,
  useMemo,
  useRef,
} from "react";
import { useAuth0 } from "@auth0/auth0-react";
import "./App.css";
import ConversationList from "./components/ConversationList";
import ChatWindow from "./components/ChatWindow";
import FeedbackPanel from "./components/FeedbackPanel";
import UserHeader from "./components/UserHeader";
import LoginPage from "./components/LoginPage";
import { createApiService } from "./services/apiService";

function App() {
  const { isAuthenticated, isLoading, getAccessTokenSilently } = useAuth0();

  // Memoize apiService to prevent recreation on every render
  const apiService = useMemo(
    () => createApiService(getAccessTokenSilently),
    [getAccessTokenSilently]
  );

  // state management
  const [conversations, setConversations] = useState([]);
  const [conversationsLoading, setConversationsLoading] = useState(false);
  const [currentConversationId, setCurrentConversationId] = useState(null);
  const [messages, setMessages] = useState([]);
  const [qualityScore, setQualityScore] = useState(null);
  const [feedback, setFeedback] = useState(null);
  const [isTerse, setIsTerse] = useState(false);
  const [loading, setLoading] = useState(false);
  const [feedbackLoading, setFeedbackLoading] = useState(false);

  // Use refs to store latest callbacks without triggering re-renders
  const loadConversationsRef = useRef();
  const loadConversationRef = useRef();
  const isSendingMessageRef = useRef(false); // Track if we're currently sending a message

  // gets all the convos
  const loadConversations = useCallback(async () => {
    if (!isAuthenticated) return;
    setConversationsLoading(true);
    try {
      const data = await apiService.getConversations();
      setConversations(data || []); // Ensure we always have an array
    } catch (error) {
      console.error("Error loading conversations:", error);
      // Don't clear conversations on error - keep existing ones
      // setConversations([]); // Removed - don't clear on error
    } finally {
      setConversationsLoading(false);
    }
  }, [isAuthenticated, apiService]);

  loadConversationsRef.current = loadConversations;

  // gets the specific convos when conversation ID changes
  const loadConversation = useCallback(
    async (conversationId) => {
      if (!conversationId) return;
      try {
        const data = await apiService.getConversation(conversationId);
        setMessages(data.messages || []);
        setQualityScore(data.quality_score);
        setFeedback(data.feedback || null); // Load feedback from conversation
        setIsTerse(data.quality_score !== null && data.quality_score <= 5.0);
        // Scroll is handled by useEffect in ChatWindow when messages change
      } catch (error) {
        // If conversation doesn't exist (404), it's expected for new conversations that haven't sent a message yet
        // Silently ignore this error - the conversation will be created when the first message is sent
        if (error.response?.status === 404) {
          // Clear messages for new conversations - this is expected behavior
          setMessages([]);
          setQualityScore(null);
          setFeedback(null);
          setIsTerse(false);
        } else {
          console.error("Error loading conversation:", error);
        }
      }
    },
    [apiService]
  );

  loadConversationRef.current = loadConversation;

  // Track if we've loaded conversations initially
  const hasLoadedConversations = useRef(false);

  // Load conversations only once when authenticated
  useEffect(() => {
    if (isAuthenticated && !hasLoadedConversations.current) {
      hasLoadedConversations.current = true;
      loadConversationsRef.current();
    }
  }, [isAuthenticated]);

  // Load conversation when currentConversationId changes
  // But don't load if we're currently sending a message (to preserve user message) - in response to user feedback
  // Also don't load if it's a new conversation that doesn't exist in the conversations list yet
  useEffect(() => {
    if (
      currentConversationId &&
      loadConversationRef.current &&
      !isSendingMessageRef.current
    ) {
      // Only load if the conversation exists in the conversations list (it's been saved to database)
      // New conversations created locally won't be in the list until the first message is sent
      const conversationExists = conversations.some(
        (conv) => conv.conversation_id === currentConversationId
      );
      if (conversationExists) {
        loadConversationRef.current(currentConversationId);
      }
    }
  }, [currentConversationId, conversations]);

  // Generate a temporary conversation ID locally (not stored in database until first message is sent)
  const createNewConversation = async () => {
    // Generate UUID locally - conversation will be created in database when first message is sent
    const conversationId = crypto.randomUUID();
    setCurrentConversationId(conversationId);
    setMessages([]);
    setQualityScore(null);
    setFeedback(null);
    setIsTerse(false);

    return conversationId;
  };

  const sendMessage = async (message, file = null) => {
    // Mark that we're sending a message to prevent loadConversation from clearing messages
    isSendingMessageRef.current = true;

    // Convert file to base64 if provided
    // file is a fileObj with {file, preview, type} from ChatWindow
    let fileAttachment = null;
    if (file && file.file) {
      const actualFile = file.file;
      console.log('DEBUG: Converting file to base64:', actualFile.name, actualFile.type, actualFile.size);
      try {
        // If it's an image and we already have a preview with base64, use that
        let fileBase64;
        if (file.type === 'image' && file.preview) {
          // Extract base64 from preview data URL
          fileBase64 = file.preview.split(',')[1];
          console.log('DEBUG: Using existing preview base64, length:', fileBase64.length);
        } else {
          // For PDFs or if preview not available, read the file
          fileBase64 = await new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => {
              // Remove data:...;base64, prefix
              const base64 = e.target.result.split(',')[1];
              console.log('DEBUG: File converted to base64, length:', base64.length);
              resolve(base64);
            };
            reader.onerror = (error) => {
              console.error('ERROR: Error converting file to base64:', error);
              reject(error);
            };
            reader.readAsDataURL(actualFile);
          });
        }
        
        fileAttachment = {
          filename: actualFile.name,
          file_type: actualFile.type || (actualFile.name.toLowerCase().endsWith('.pdf') ? 'application/pdf' : 'image/jpeg'),
          data: fileBase64
        };
        console.log('DEBUG: File ready to send:', { fileName: fileAttachment.filename, fileType: fileAttachment.file_type, base64Length: fileBase64.length });
      } catch (error) {
        console.error('ERROR: Error converting file to base64:', error);
        alert('Failed to process file. Please try again.');
        isSendingMessageRef.current = false;
        return;
      }
    }

    // Add user message immediately to the chat FIRST (before any async operations)
    const userMessage = {
      role: "user",
      content: message || "",
      timestamp: new Date().toISOString(),
      ...(fileAttachment && {
        attachments: [{
          filename: fileAttachment.filename,
          file_type: fileAttachment.file_type
        }]
      })
    };
    setMessages((prev) => [...prev, userMessage]);

    // Ensure we have a conversation ID
    let activeConversationId = currentConversationId;
    if (!activeConversationId) {
      // Generate a new conversation ID if we somehow don't have one
      activeConversationId = crypto.randomUUID();
      setCurrentConversationId(activeConversationId);
    }

    setLoading(true);
    setFeedbackLoading(true);
    try {
      // Step 1: Get feedback and score immediately
      // Backend will create the conversation if it doesn't exist
      const feedbackResponse = await apiService.sendMessage(
        activeConversationId,
        message,
        fileAttachment
      );

      console.log("DEBUG: Feedback Response:", feedbackResponse);

      // Update feedback and score immediately
      setQualityScore(feedbackResponse.quality_score);
      setFeedback(feedbackResponse.feedback);
      setIsTerse(
        feedbackResponse.quality_score !== null &&
        feedbackResponse.quality_score <= 5.0
      );

      // Store title for later use when updating conversation list
      const updated_title = feedbackResponse.title;
      
      // Update conversation title in the list if it was generated and move to top
      if (updated_title) {
        setConversations((prev) => {
          const exists = prev.some((conv) => conv.conversation_id === activeConversationId);
          if (exists) {
            // Find and update the conversation, then move it to the top
            const conv = prev.find((c) => c.conversation_id === activeConversationId);
            const updatedConv = { ...conv, title: updated_title, updated_at: new Date().toISOString() };
            const otherConvs = prev.filter((c) => c.conversation_id !== activeConversationId);
            return [updatedConv, ...otherConvs];
          }
          return prev;
        });
      }

      // Stop feedback loading immediately
      setFeedbackLoading(false);

      // Step 2: Get AI response after feedback is ready (streaming)
      // Don't add message until first chunk arrives
      const streamingMessageId = Date.now();
      let streamingMessageAdded = false;

      // Stream AI response
      let fullResponse = "";

      await apiService.getAIResponse(
        activeConversationId,
        // onChunk callback - update state immediately for each chunk
        (chunk) => {
          fullResponse += chunk;

          // Add the streaming message only when first chunk arrives
          if (!streamingMessageAdded) {
            streamingMessageAdded = true;
            const streamingMessage = {
              role: "assistant",
              content: fullResponse,
              timestamp: new Date().toISOString(),
              _streaming: true,
              _id: streamingMessageId,
            };
            setMessages((prev) => [...prev, streamingMessage]);
          } else {
            // Update state immediately - React 18 will handle batching appropriately
            setMessages((prev) => {
              const updated = prev.map((msg) =>
                msg._id === streamingMessageId
                  ? { ...msg, content: fullResponse }
                  : msg
              );
              return updated;
            });
          }
        },
        // onComplete callback
        (completeResponse) => {
          // Replace streaming message with final message
          setMessages((prev) => {
            const updated = prev.map((msg) =>
              msg._id === streamingMessageId
                ? {
                    role: "assistant",
                    content: completeResponse || fullResponse,
                    timestamp: new Date().toISOString(),
                  }
                : msg
            );
            
            // Update conversations list - update in place and move to top to avoid flickering
            if (isAuthenticated) {
              // Get current messages count after update - count ALL messages (user + assistant)
              const totalMessageCount = updated.length;
              
              // If this is a new conversation (not in list yet), add it
              setConversations((prevConvs) => {
                const conversationExists = prevConvs.some(
                  (conv) => conv.conversation_id === activeConversationId
                );
                
                if (!conversationExists) {
                  // Add new conversation to the list
                  // Use current timestamp - will be updated from backend on next load
                  const now = new Date().toISOString();
                  const newConversation = {
                    conversation_id: activeConversationId,
                    title: updated_title || "New Conversation",
                    created_at: now,
                    updated_at: now,
                    message_count: totalMessageCount,
                  };
                  return [newConversation, ...prevConvs];
                } else {
                  // Update existing conversation and move it to the top
                  const updatedConversation = {
                    conversation_id: activeConversationId,
                    title: updated_title || prevConvs.find(c => c.conversation_id === activeConversationId)?.title,
                    created_at: prevConvs.find(c => c.conversation_id === activeConversationId)?.created_at,
                    updated_at: new Date().toISOString(),
                    message_count: totalMessageCount,
                  };
                  // Remove the conversation from its current position and add it to the top
                  const otherConvs = prevConvs.filter(
                    (conv) => conv.conversation_id !== activeConversationId
                  );
                  return [updatedConversation, ...otherConvs];
                }
              });
            }
            
            return updated;
          });

          // Message sending is complete, allow loadConversation to run again
          isSendingMessageRef.current = false;
          setLoading(false);
        },
        // onError callback
        (errorData) => {
          console.error("Streaming error:", errorData);
          // Remove streaming message on error
          setMessages((prev) =>
            prev.filter((msg) => msg._id !== streamingMessageId)
          );

          let errorMessage = "Failed to get AI response. ";
          if (errorData.error) {
            errorMessage += errorData.error;
          } else if (errorData.details) {
            errorMessage += errorData.details;
          }

          alert(errorMessage);
          isSendingMessageRef.current = false;
          setLoading(false);
        }
      );
    } catch (error) {
      console.error("Error sending message:", error);

      // Handle different error types
      let errorMessage = "Failed to send message. ";
      if (error.response) {
        // Server responded with error
        const status = error.response.status;
        const data = error.response.data;

        if (status === 401) {
          errorMessage +=
            "Authentication failed. Please try logging out and back in.";
        } else if (status === 429) {
          errorMessage +=
            "Too many requests. Please wait a moment and try again.";
        } else if (status === 500) {
          errorMessage += "Server error occurred. Please try again.";
        } else if (status === 400 && data?.message) {
          // Use the message field if available (e.g., conversation limit reached)
          errorMessage = data.message;
        } else if (data?.error) {
          errorMessage += data.error;
        } else {
          errorMessage += `Error ${status}: ${
            error.message || "Unknown error"
          }`;
        }
      } else if (error.request) {
        // Request made but no response
        errorMessage +=
          "No response from server. Please check your connection.";
      } else {
        // Other error
        errorMessage += error.message || "Unknown error occurred.";
      }

      // Show error message to user
      alert(errorMessage);

      // Remove the user message if there was an error
      setMessages((prev) => prev.filter((msg) => msg !== userMessage));
      // Allow loadConversation to run again even on error
      isSendingMessageRef.current = false;
    } finally {
      setLoading(false);
      setFeedbackLoading(false);
    }
  };

  const selectConversation = (conversationId) => {
    setCurrentConversationId(conversationId);
  };

  if (isLoading) {
    return (
      <div className="app app-loading">
        <div className="loading-container">
          <div className="loading-spinner"></div>
        </div>
      </div>
    );
  }

  if (!isAuthenticated) {
    return <LoginPage />;
  }

  return (
    <div className="app">
      <UserHeader />
      <div className="app-container">
        <ConversationList
          conversations={conversations}
          currentConversationId={currentConversationId}
          onSelectConversation={selectConversation}
          onCreateNew={createNewConversation}
          loading={conversationsLoading}
          isNewConversation={messages.length === 0}
        />

        <ChatWindow
          messages={messages}
          onSendMessage={sendMessage}
          loading={loading}
          isTerse={isTerse}
          isLimitReached={
            messages.filter((msg) => msg.role === "user").length >= 20
          }
        />

        <FeedbackPanel
          qualityScore={qualityScore}
          feedback={feedback}
          isTerse={isTerse}
          loading={feedbackLoading}
        />
      </div>
    </div>
  );
}

export default App;
