// IMPORTANT NOTE: This and the associated css file were generated by Cursor and sets up the main functions of the application.*/
import React, {
  useState,
  useEffect,
  useCallback,
  useMemo,
  useRef,
} from "react";
import { useAuth0 } from "@auth0/auth0-react";
import "./App.css";
import ConversationList from "./components/ConversationList";
import ChatWindow from "./components/ChatWindow";
import FeedbackPanel from "./components/FeedbackPanel";
import UserHeader from "./components/UserHeader";
import LoginPage from "./components/LoginPage";
import MobileWarning from "./components/MobileWarning";
import ConfirmationModal from "./components/ConfirmationModal";
import { createApiService } from "./services/apiService";

function App() {
  const { isAuthenticated, isLoading, getAccessTokenSilently } = useAuth0();

  // Memoize apiService to prevent recreation on every render
  const apiService = useMemo(
    () => createApiService(getAccessTokenSilently),
    [getAccessTokenSilently]
  );

  // state management
  const [conversations, setConversations] = useState([]);
  const [conversationsLoading, setConversationsLoading] = useState(false);
  const [currentConversationId, setCurrentConversationId] = useState(null);
  const [messages, setMessages] = useState([]);
  const [qualityScore, setQualityScore] = useState(null);
  const [feedback, setFeedback] = useState(null);
  const [isTerse, setIsTerse] = useState(false);
  const [loading, setLoading] = useState(false);
  const [feedbackLoading, setFeedbackLoading] = useState(false);
  const [isNarrowWindow, setIsNarrowWindow] = useState(window.innerWidth < 800);
  const [showDeleteConfirm, setShowDeleteConfirm] = useState(false);
  const [conversationToDelete, setConversationToDelete] = useState(null);

  // Use refs to store latest callbacks without triggering re-renders
  const loadConversationsRef = useRef();
  const loadConversationRef = useRef();
  const isSendingMessageRef = useRef(false); // Track if we're currently sending a message
  const abortControllerRef = useRef(null); // Track active streaming request for abort capability
  const feedbackAbortControllerRef = useRef(null); // Track active feedback request for abort capability

  // Handle window resize to detect narrow windows (display the mobile warning if so)
  useEffect(() => {
    const handleResize = () => {
      setIsNarrowWindow(window.innerWidth < 800);
    };

    window.addEventListener("resize", handleResize);
    return () => window.removeEventListener("resize", handleResize);
  }, []);

  // gets all the convos
  const loadConversations = useCallback(async () => {
    if (!isAuthenticated) return;
    // displays the loading state
    setConversationsLoading(true);
    try {
      const data = await apiService.getConversations();
      setConversations(data || []);
    } catch (error) {
      console.error("Error loading conversations:", error);
      // Don't clear conversations on error - keep existing ones
      // setConversations([]); // Removed - don't clear on error
    } finally {
      setConversationsLoading(false);
    }
  }, [isAuthenticated, apiService]);

  loadConversationsRef.current = loadConversations;

  // gets the specific convos when user clicks on a conversation
  const loadConversation = useCallback(
    async (conversationId) => {
      if (!conversationId) return;
      try {
        const data = await apiService.getConversation(conversationId);
        setMessages(data.messages || []);
        setQualityScore(data.quality_score);
        setFeedback(data.feedback || null); // Load feedback from conversation
        setIsTerse(data.quality_score !== null && data.quality_score <= 5.0);
        // Scroll is handled by useEffect in ChatWindow when messages change
      } catch (error) {
        // If conversation doesn't exist (404), it's expected for new conversations that haven't sent a message yet so just silently ignore it
        if (error.response?.status === 404) {
          // Clear messages for new conversations - this is expected behavior
          setMessages([]);
          setQualityScore(null);
          setFeedback(null);
          setIsTerse(false);
        } else {
          console.error("Error loading conversation:", error);
        }
      }
    },
    [apiService]
  );

  loadConversationRef.current = loadConversation;

  // Track if we've loaded conversations initially
  const hasLoadedConversations = useRef(false);

  // Load conversations only once when authenticated
  useEffect(() => {
    if (isAuthenticated && !hasLoadedConversations.current) {
      hasLoadedConversations.current = true;
      loadConversationsRef.current();
    }
  }, [isAuthenticated]);

  // Load conversation when currentConversationId changes
  // But don't load if we're currently sending a message (to preserve user message) - in response to user feedback
  // Also don't load if it's a new conversation that doesn't exist in the conversations list yet
  useEffect(() => {
    if (
      currentConversationId &&
      loadConversationRef.current &&
      !isSendingMessageRef.current
    ) {
      // new conversations created locally won't be in the list until the first message is sent
      const conversationExists = conversations.some(
        (conv) => conv.conversation_id === currentConversationId
      );
      if (conversationExists) {
        loadConversationRef.current(currentConversationId);
      }
    }
  }, [currentConversationId, conversations]);

  // Generate a temporary conversation ID locally (not stored in database until first message is sent)
  const createNewConversation = async () => {
    // Generate UUID locally - conversation will be created in database when first message is sent
    const conversationId = crypto.randomUUID();
    setCurrentConversationId(conversationId);
    setMessages([]);
    setQualityScore(null);
    setFeedback(null);
    setIsTerse(false);

    return conversationId;
  };

  const sendMessage = async (message, files = null) => {
    // Mark that we're sending a message to prevent loadConversation from clearing messages
    isSendingMessageRef.current = true;

    // Convert files to base64 if provided
    // files is an array of fileObj with {file, preview, type} from ChatWindow
    let fileAttachments = null;
    if (files && Array.isArray(files) && files.length > 0) {
      try {
        fileAttachments = await Promise.all(
          files.map(async (fileObj) => {
            if (!fileObj || !fileObj.file) {
              return null;
            }

            const actualFile = fileObj.file;
            let fileBase64;

            // If it's an image and we already have a preview with base64, use that
            if (fileObj.type === "image" && fileObj.preview) {
              // Extract base64 from preview data URL
              fileBase64 = fileObj.preview.split(",")[1];
            } else {
              // For PDFs or if preview not available, read the file
              fileBase64 = await new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                  // Remove data:...;base64, prefix
                  const base64 = e.target.result.split(",")[1];
                  resolve(base64);
                };
                reader.onerror = (error) => {
                  console.error(
                    "ERROR: Error converting file to base64:",
                    error
                  );
                  reject(error);
                };
                reader.readAsDataURL(actualFile);
              });
            }

            return {
              filename: actualFile.name,
              file_type:
                actualFile.type ||
                (actualFile.name.toLowerCase().endsWith(".pdf")
                  ? "application/pdf"
                  : "image/jpeg"),
              data: fileBase64,
            };
          })
        );

        // Filter out any null entries
        fileAttachments = fileAttachments.filter((att) => att !== null);

        // If all files failed, set to null
        if (fileAttachments.length === 0) {
          fileAttachments = null;
        }
      } catch (error) {
        console.error("ERROR: Error converting files to base64:", error);
        alert("Failed to process files. Please try again.");
        isSendingMessageRef.current = false;
        return;
      }
    }

    // Add user message immediately to the chat first before any async operations
    const userMessage = {
      role: "user",
      content: message || "",
      timestamp: new Date().toISOString(),
      ...(fileAttachments && {
        attachments: fileAttachments.map((att) => ({
          filename: att.filename,
          file_type: att.file_type,
        })),
      }),
    };
    setMessages((prev) => [...prev, userMessage]);

    // Ensure we have a conversation ID
    let activeConversationId = currentConversationId;
    if (!activeConversationId) {
      // Generate a new conversation ID if we somehow don't have one - mostly a fallback this should probably not happen
      activeConversationId = crypto.randomUUID();
      setCurrentConversationId(activeConversationId);
    }

    setLoading(true);
    setFeedbackLoading(true);

    // Create AbortController for feedback request in case we delete the conversation mid way thru
    feedbackAbortControllerRef.current = new AbortController();

    try {
      // Step 1: Get feedback and score immediately
      // Backend will create the conversation if it doesn't exist
      const feedbackResponse = await apiService.sendMessage(
        activeConversationId,
        message,
        fileAttachments,
        feedbackAbortControllerRef.current.signal
      );

      // Update feedback and score immediately
      setQualityScore(feedbackResponse.quality_score);
      setFeedback(feedbackResponse.feedback);
      setIsTerse(
        feedbackResponse.quality_score !== null &&
          feedbackResponse.quality_score <= 5.0
      );

      // Store title for later use when updating conversation list
      const updated_title = feedbackResponse.title;

      // Stop feedback loading immediately
      setFeedbackLoading(false);

      // Clear feedback abort controller on successful completion
      feedbackAbortControllerRef.current = null;

      // Step 2: Get AI response after feedback is ready (streaming)
      // don't add message until first chunk comes
      const streamingMessageId = Date.now();
      let streamingMessageAdded = false;

      // create AbortController for this stream in case user deletes the conversation mid way thru
      abortControllerRef.current = new AbortController();

      // Stream AI response
      let fullResponse = "";

      await apiService.getAIResponse(
        activeConversationId,
        // onChunk callback - update state immediately for each chunk
        (chunk) => {
          fullResponse += chunk;

          // Add the streaming message only when first chunk arrives
          if (!streamingMessageAdded) {
            streamingMessageAdded = true;
            const streamingMessage = {
              role: "assistant",
              content: fullResponse,
              timestamp: new Date().toISOString(),
              _streaming: true,
              _id: streamingMessageId,
            };
            setMessages((prev) => [...prev, streamingMessage]);
          } else {
            // Update state immediately - React 18 will handle batching appropriately
            setMessages((prev) => {
              const updated = prev.map((msg) =>
                msg._id === streamingMessageId
                  ? { ...msg, content: fullResponse }
                  : msg
              );
              return updated;
            });
          }
        },
        // onComplete callback once the stream is complete
        (completeResponse) => {
          // Clear abort controller on completion
          abortControllerRef.current = null;

          // Replace streaming message with final message
          setMessages((prev) => {
            const updated = prev.map((msg) =>
              msg._id === streamingMessageId
                ? {
                    role: "assistant",
                    content: completeResponse || fullResponse,
                    timestamp: new Date().toISOString(),
                  }
                : msg
            );

            // Update conversations list - update in place and move to top to avoid flickering
            if (isAuthenticated) {
              // Get current messages count after update - count ALL messages (user + assistant)
              const totalMessageCount = updated.length;

              // If this is a new conversation (not in list yet), add it
              setConversations((prevConvs) => {
                const conversationExists = prevConvs.some(
                  (conv) => conv.conversation_id === activeConversationId
                );

                if (!conversationExists) {
                  // Add new conversation to the list
                  // Use current timestamp - will be updated from backend on next load
                  const now = new Date().toISOString();
                  const newConversation = {
                    conversation_id: activeConversationId,
                    title: updated_title || "New Conversation",
                    created_at: now,
                    updated_at: now,
                    message_count: totalMessageCount,
                  };
                  return [newConversation, ...prevConvs];
                } else {
                  // Update existing conversation and move it to the top
                  const updatedConversation = {
                    conversation_id: activeConversationId,
                    title:
                      updated_title ||
                      prevConvs.find(
                        (c) => c.conversation_id === activeConversationId
                      )?.title,
                    created_at: prevConvs.find(
                      (c) => c.conversation_id === activeConversationId
                    )?.created_at,
                    updated_at: new Date().toISOString(),
                    message_count: totalMessageCount,
                  };
                  // Remove the conversation from its current position and add it to the top
                  const otherConvs = prevConvs.filter(
                    (conv) => conv.conversation_id !== activeConversationId
                  );
                  return [updatedConversation, ...otherConvs];
                }
              });
            }

            return updated;
          });

          // Message sending is complete, allow loadConversation to run again
          isSendingMessageRef.current = false;
          setLoading(false);
        },
        // onError callback
        (errorData) => {
          // Clear abort controller on error
          abortControllerRef.current = null;
          console.error("Streaming error:", errorData);

          // Check if this is a connection abort (e.g., page refresh or user-initiated abort)
          const errorMessageLower = errorData.error?.toLowerCase() || "";
          const isConnectionAbort =
            errorMessageLower.includes("failed to fetch") ||
            errorMessageLower.includes("networkerror") ||
            errorMessageLower.includes("network error") ||
            errorMessageLower.includes("aborted") ||
            errorMessageLower.includes("aborterror") ||
            errorData.error?.name === "TypeError" || // Failed to fetch is a TypeError
            errorData.error?.name === "AbortError";

          // Remove streaming message on error
          setMessages((prev) =>
            prev.filter((msg) => msg._id !== streamingMessageId)
          );

          // Only show alert if it's not a connection abort
          if (!isConnectionAbort) {
            let errorMessage = "Failed to get AI response. ";
            if (errorData.error) {
              errorMessage += errorData.error;
            } else if (errorData.details) {
              errorMessage += errorData.details;
            }
            alert(errorMessage);
          } else {
            // Silently handle connection abort - user likely refreshed
            console.log(
              "Streaming connection aborted (likely due to page refresh)"
            );
          }

          isSendingMessageRef.current = false;
          setLoading(false);
        },
        // AbortController signal
        abortControllerRef.current?.signal
      );
    } catch (error) {
      // the rest is error handling, lot of different types of errors
      // Clear feedback abort controller on error
      feedbackAbortControllerRef.current = null;

      // Check if error is due to abort
      const isAbortError =
        error.name === "AbortError" ||
        error.name === "CanceledError" ||
        error.code === "ERR_CANCELED" ||
        (error.message && error.message.includes("canceled"));

      if (isAbortError) {
        // Silently handle abort - conversation was likely deleted
        console.log("Feedback request aborted");

        // Remove the user message that was added
        setMessages((prev) => {
          // Remove the last user message (the one that triggered this request)
          const userMessages = prev.filter((msg) => msg.role === "user");
          if (userMessages.length > 0) {
            const lastUserMessage = userMessages[userMessages.length - 1];
            return prev.filter((msg) => msg !== lastUserMessage);
          }
          return prev;
        });

        // Reset loading states
        setLoading(false);
        setFeedbackLoading(false);
        isSendingMessageRef.current = false;
        return;
      }

      console.error("Error sending message:", error);

      // Handle different error types
      let errorMessage = "Failed to send message. ";
      if (error.response) {
        // Server responded with error
        const status = error.response.status;
        const data = error.response.data;

        if (status === 401) {
          errorMessage +=
            "Authentication failed. Please try logging out and back in.";
        } else if (status === 429) {
          errorMessage +=
            "Too many requests. Please wait a moment and try again.";
        } else if (status === 500) {
          errorMessage += "Server error occurred. Please try again.";
        } else if (status === 400 && data?.message) {
          // Use the message field if available (e.g., conversation limit reached)
          errorMessage = data.message;
        } else if (data?.error) {
          errorMessage += data.error;
        } else {
          errorMessage += `Error ${status}: ${
            error.message || "Unknown error"
          }`;
        }
      } else if (error.request) {
        // Request made but no response
        errorMessage +=
          "No response from server. Please check your connection.";
      } else {
        // Other error
        errorMessage += error.message || "Unknown error occurred.";
      }

      // Show error message to user
      alert(errorMessage);

      // Remove the user message if there was an error
      setMessages((prev) => prev.filter((msg) => msg !== userMessage));
      // Allow loadConversation to run again even on error
      isSendingMessageRef.current = false;
    } finally {
      setLoading(false);
      setFeedbackLoading(false);
    }
  };

  // Check if response is being generated (from when user sends message until response completes)
  const isStreaming = useMemo(() => {
    // Disable navigation as soon as user sends a message (loading becomes true)
    // and keep it disabled until response completes (loading becomes false)
    return loading;
  }, [loading]);

  const selectConversation = (conversationId) => {
    setCurrentConversationId(conversationId);
  };

  const handleDeleteClick = (conversationId) => {
    setConversationToDelete(conversationId);
    setShowDeleteConfirm(true);
  };
  // popup, user clicks delete
  const handleDeleteConfirm = async () => {
    if (!conversationToDelete) return;

    setShowDeleteConfirm(false);

    // Check if we need to abort active requests for this conversation
    const isDeletingActiveConversation =
      currentConversationId === conversationToDelete;
    const hasActiveStream = abortControllerRef.current !== null;
    const hasActiveFeedback = feedbackAbortControllerRef.current !== null;

    // If deleting the active conversation and there's a feedback request, abort it
    if (isDeletingActiveConversation && hasActiveFeedback) {
      feedbackAbortControllerRef.current.abort();
      feedbackAbortControllerRef.current = null;

      // Remove the last user message (the one that triggered the feedback)
      setMessages((prev) => {
        const userMessages = prev.filter((msg) => msg.role === "user");
        if (userMessages.length > 0) {
          const lastUserMessage = userMessages[userMessages.length - 1];
          return prev.filter((msg) => msg !== lastUserMessage);
        }
        return prev;
      });

      // Reset loading states
      setLoading(false);
      setFeedbackLoading(false);
      isSendingMessageRef.current = false;
    }

    // If deleting the active conversation and there's a stream, abort it
    if (isDeletingActiveConversation && hasActiveStream) {
      abortControllerRef.current.abort();
      abortControllerRef.current = null;

      // Remove streaming messages from the UI
      setMessages((prev) => prev.filter((msg) => !msg._streaming));

      // Clear loading state
      setLoading(false);
    }

    try {
      await apiService.deleteConversation(conversationToDelete);

      // If the deleted conversation is currently open, clear it
      if (isDeletingActiveConversation) {
        setCurrentConversationId(null);
        setMessages([]);
        setQualityScore(null);
        setFeedback(null);
        setIsTerse(false);
      }

      // Reload conversations list after we delete to reflect the deletion
      await loadConversations();
    } catch (error) {
      console.error("Error deleting conversation:", error);
      let errorMessage = "Failed to delete conversation. ";
      if (error.response) {
        const status = error.response.status;
        const data = error.response.data;

        if (status === 404) {
          errorMessage = "Conversation not found.";
        } else if (status === 401) {
          errorMessage =
            "Authentication failed. Please try logging out and back in.";
        } else if (data?.error) {
          errorMessage += data.error;
        } else {
          errorMessage += `Error ${status}: ${
            error.message || "Unknown error"
          }`;
        }
      } else {
        errorMessage += error.message || "Unknown error occurred.";
      }

      alert(errorMessage);
    } finally {
      setConversationToDelete(null);
    }
  };

  // user goes back on what they wanted to do
  const handleDeleteCancel = () => {
    setShowDeleteConfirm(false);
    setConversationToDelete(null);
  };

  if (isLoading) {
    return (
      <div className="app app-loading">
        <div className="loading-container">
          <div className="loading-spinner"></div>
        </div>
      </div>
    );
  }

  // Show warning for narrow windows (mobile or narrow desktop)
  if (isNarrowWindow) {
    return <MobileWarning />;
  }

  if (!isAuthenticated) {
    return <LoginPage />;
  }

  return (
    <div className="app">
      <UserHeader />
      <div className="app-container">
        <ConversationList
          conversations={conversations}
          currentConversationId={currentConversationId}
          onSelectConversation={selectConversation}
          onCreateNew={createNewConversation}
          onDeleteConversation={handleDeleteClick}
          loading={conversationsLoading}
          isNewConversation={messages.length === 0}
          isStreaming={isStreaming}
        />

        <ChatWindow
          messages={messages}
          onSendMessage={sendMessage}
          loading={loading}
          isTerse={isTerse}
          isLimitReached={
            messages.filter((msg) => msg.role === "user").length >= 20
          }
        />

        <FeedbackPanel
          qualityScore={qualityScore}
          feedback={feedback}
          isTerse={isTerse}
          loading={feedbackLoading}
        />
      </div>
      <ConfirmationModal
        isOpen={showDeleteConfirm}
        title="Delete Conversation"
        message="Are you sure you want to delete this conversation? This action cannot be undone."
        confirmText="Delete"
        cancelText="Cancel"
        onConfirm={handleDeleteConfirm}
        onCancel={handleDeleteCancel}
        confirmButtonColor="#d32f2f"
      />
    </div>
  );
}

export default App;
