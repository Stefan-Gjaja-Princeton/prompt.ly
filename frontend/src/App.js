/* IMPORTANT NOTE: This was generated by Cursor and sets up the main functions of the application.*/
import React, {
  useState,
  useEffect,
  useCallback,
  useMemo,
  useRef,
} from "react";
import { useAuth0 } from "@auth0/auth0-react";
import "./App.css";
import ConversationList from "./components/ConversationList";
import ChatWindow from "./components/ChatWindow";
import FeedbackPanel from "./components/FeedbackPanel";
import UserHeader from "./components/UserHeader";
import LoginPage from "./components/LoginPage";
import { createApiService } from "./services/apiService";

function App() {
  const { isAuthenticated, isLoading, getAccessTokenSilently } = useAuth0();

  // Memoize apiService to prevent recreation on every render
  const apiService = useMemo(
    () => createApiService(getAccessTokenSilently),
    [getAccessTokenSilently]
  );

  const [conversations, setConversations] = useState([]);
  const [currentConversationId, setCurrentConversationId] = useState(null);
  const [messages, setMessages] = useState([]);
  const [qualityScore, setQualityScore] = useState(null);
  const [feedback, setFeedback] = useState("");
  const [isTerse, setIsTerse] = useState(false);
  const [loading, setLoading] = useState(false);
  const [feedbackLoading, setFeedbackLoading] = useState(false);

  // Use refs to store latest callbacks without triggering re-renders
  const loadConversationsRef = useRef();
  const loadConversationRef = useRef();
  const isSendingMessageRef = useRef(false); // Track if we're currently sending a message

  // Stable callback that doesn't depend on apiService directly
  const loadConversations = useCallback(async () => {
    if (!isAuthenticated) return;
    try {
      const data = await apiService.getConversations();
      setConversations(data);
    } catch (error) {
      console.error("Error loading conversations:", error);
    }
  }, [isAuthenticated, apiService]);

  loadConversationsRef.current = loadConversations;

  const loadConversation = useCallback(
    async (conversationId) => {
      if (!conversationId) return;
      try {
        const data = await apiService.getConversation(conversationId);
        setMessages(data.messages || []);
        setQualityScore(data.quality_score);
        setFeedback(data.feedback || ""); // Load feedback from conversation
        setIsTerse(data.quality_score !== null && data.quality_score <= 5.0);
      } catch (error) {
        console.error("Error loading conversation:", error);
      }
    },
    [apiService]
  );

  loadConversationRef.current = loadConversation;

  // Track if we've loaded conversations initially
  const hasLoadedConversations = useRef(false);

  // Load conversations only once when authenticated
  useEffect(() => {
    if (isAuthenticated && !hasLoadedConversations.current) {
      hasLoadedConversations.current = true;
      loadConversationsRef.current();
    }
  }, [isAuthenticated]);

  // Load conversation when currentConversationId changes
  // But don't load if we're currently sending a message (to preserve user message)
  useEffect(() => {
    if (
      currentConversationId &&
      loadConversationRef.current &&
      !isSendingMessageRef.current
    ) {
      loadConversationRef.current(currentConversationId);
    }
  }, [currentConversationId]);

  const createNewConversation = async () => {
    try {
      const data = await apiService.createConversation();
      const newConversation = {
        conversation_id: data.conversation_id,
        title: "New Conversation",
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
        message_count: 0,
      };

      // Update conversations without triggering a reload
      setConversations((prev) => [newConversation, ...prev]);
      setCurrentConversationId(data.conversation_id);
      setMessages([]);
      setQualityScore(null);
      setFeedback("");
      setIsTerse(false);

      return data.conversation_id;
    } catch (error) {
      console.error("Error creating conversation:", error);
      throw error;
    }
  };

  const sendMessage = async (message) => {
    // Mark that we're sending a message to prevent loadConversation from clearing messages
    isSendingMessageRef.current = true;

    // Add user message immediately to the chat FIRST (before any async operations)
    const userMessage = {
      role: "user",
      content: message,
      timestamp: new Date().toISOString(),
    };
    setMessages((prev) => [...prev, userMessage]);

    // Ensure we have a conversation to send into; create one if needed
    let activeConversationId = currentConversationId;
    if (!activeConversationId) {
      try {
        // Create conversation but don't clear messages - preserve the user message we just added
        const data = await apiService.createConversation();
        activeConversationId = data.conversation_id;
        const newConversation = {
          conversation_id: data.conversation_id,
          title: "New Conversation",
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString(),
          message_count: 0,
        };
        setConversations((prev) => [newConversation, ...prev]);
        setCurrentConversationId(data.conversation_id);
        // Don't clear messages here - we already added the user message above
      } catch (e) {
        // Better error message extraction
        let errorMessage = "Failed to create conversation. ";

        if (e.response) {
          // Server responded with error
          const status = e.response.status;
          const data = e.response.data;

          if (status === 401) {
            errorMessage +=
              "Authentication failed. Please try logging out and back in.";
          } else if (status === 500) {
            errorMessage +=
              "Server error occurred. Please check if the backend is running.";
          } else if (data?.error) {
            errorMessage += data.error;
          } else {
            errorMessage += `Server returned error ${status}`;
          }
        } else if (e.request) {
          // Request made but no response - network error
          errorMessage += "Network error - unable to reach the server. ";
          errorMessage += "Please check:\n";
          errorMessage += "1. Is the backend service running?\n";
          errorMessage +=
            "2. Check the browser console (F12) for more details.\n";
          errorMessage += `3. Verify REACT_APP_API_URL is set correctly.`;
        } else {
          // Other error
          errorMessage += e.message || String(e);
        }

        console.error("Error creating conversation:", e);
        alert(errorMessage);

        // Remove the user message if conversation creation failed
        setMessages((prev) => prev.filter((msg) => msg !== userMessage));
        isSendingMessageRef.current = false;
        return;
      }
    }

    setLoading(true);
    setFeedbackLoading(true);
    try {
      // Step 1: Get feedback and score immediately
      const feedbackResponse = await apiService.sendMessage(
        activeConversationId,
        message
      );

      console.log("DEBUG: Feedback Response:", feedbackResponse);

      // Update feedback and score immediately
      setQualityScore(feedbackResponse.quality_score);
      setFeedback(feedbackResponse.feedback);
      setIsTerse(
        feedbackResponse.quality_score !== null &&
          feedbackResponse.quality_score <= 5.0
      );

      // Stop feedback loading immediately
      setFeedbackLoading(false);

      // Step 2: Get AI response after feedback is ready
      const aiResponse = await apiService.getAIResponse(activeConversationId);

      console.log("DEBUG: AI Response:", aiResponse);

      // Update with the complete message history including AI response
      setMessages(aiResponse.messages);

      // Update conversations list only when needed (after message is sent)
      // This updates the conversation title and message count
      // Only reload if needed to update the conversation metadata
      if (isAuthenticated) {
        loadConversations();
      }

      // Message sending is complete, allow loadConversation to run again
      isSendingMessageRef.current = false;
    } catch (error) {
      console.error("Error sending message:", error);

      // Handle different error types
      let errorMessage = "Failed to send message. ";
      if (error.response) {
        // Server responded with error
        const status = error.response.status;
        const data = error.response.data;

        if (status === 401) {
          errorMessage +=
            "Authentication failed. Please try logging out and back in.";
        } else if (status === 429) {
          errorMessage +=
            "Too many requests. Please wait a moment and try again.";
        } else if (status === 500) {
          errorMessage += "Server error occurred. Please try again.";
        } else if (data?.error) {
          errorMessage += data.error;
        } else {
          errorMessage += `Error ${status}: ${
            error.message || "Unknown error"
          }`;
        }
      } else if (error.request) {
        // Request made but no response
        errorMessage +=
          "No response from server. Please check your connection.";
      } else {
        // Other error
        errorMessage += error.message || "Unknown error occurred.";
      }

      // Show error message to user
      alert(errorMessage);

      // Remove the user message if there was an error
      setMessages((prev) => prev.filter((msg) => msg !== userMessage));
      // Allow loadConversation to run again even on error
      isSendingMessageRef.current = false;
    } finally {
      setLoading(false);
      setFeedbackLoading(false);
    }
  };

  const selectConversation = (conversationId) => {
    setCurrentConversationId(conversationId);
  };

  if (isLoading) {
    return (
      <div className="app app-loading">
        <div className="loading-container">
          <div className="loading-spinner"></div>
        </div>
      </div>
    );
  }

  if (!isAuthenticated) {
    return <LoginPage />;
  }

  return (
    <div className="app">
      <UserHeader />
      <div className="app-container">
        <ConversationList
          conversations={conversations}
          currentConversationId={currentConversationId}
          onSelectConversation={selectConversation}
          onCreateNew={createNewConversation}
        />

        <ChatWindow
          messages={messages}
          onSendMessage={sendMessage}
          loading={loading}
          isTerse={isTerse}
        />

        <FeedbackPanel
          qualityScore={qualityScore}
          feedback={feedback}
          isTerse={isTerse}
          loading={feedbackLoading}
        />
      </div>
    </div>
  );
}

export default App;
