// IMPORTANT NOTE: This and the associated css file were generated by Cursor with a lot of back-and-forth - I have very little
//experience with frontend development, especially using React, so it could help me implement
//things that I was more familiar with in this language.
import React, { useState, useRef, useEffect } from "react";
import { useAuth0 } from "@auth0/auth0-react";
import { Send, User, AlertTriangle } from "lucide-react";
import "./ChatWindow.css";
import logo from "../assets/promptly_logo.png";
import { renderMarkdown } from "../utils/markdown";
import PromptlyMascot from "./icons/IconMascot";

const ChatWindow = ({
  messages,
  onSendMessage,
  loading,
  isTerse,
  isLimitReached = false,
}) => {
  const { user } = useAuth0();
  const [userImageError, setUserImageError] = useState(false);
  const [inputMessage, setInputMessage] = useState("");
  const messagesEndRef = useRef(null);
  const messagesContainerRef = useRef(null);
  const inputRef = useRef(null);
  const previousMessageCountRef = useRef(0);

  // Handle copy button clicks for code blocks
  useEffect(() => {
    const handleCopyClick = async (e) => {
      if (e.target.closest(".copy-code-button")) {
        const button = e.target.closest(".copy-code-button");
        const code = button.getAttribute("data-code");

        if (code) {
          try {
            // Decode HTML entities
            const tempDiv = document.createElement("div");
            tempDiv.innerHTML = code;
            const decodedCode = tempDiv.textContent || tempDiv.innerText || "";

            await navigator.clipboard.writeText(decodedCode);

            // Visual feedback - change button text temporarily
            const originalHTML = button.innerHTML;
            button.innerHTML =
              '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M13.854 3.646a.5.5 0 0 1 0 .708l-7 7a.5.5 0 0 1-.708 0l-3.5-3.5a.5.5 0 1 1 .708-.708L6.5 10.293l6.646-6.647a.5.5 0 0 1 .708 0z" fill="currentColor"/></svg>';
            button.style.color = "#28a745";

            setTimeout(() => {
              button.innerHTML = originalHTML;
              button.style.color = "";
            }, 2000);
          } catch (err) {
            console.error("Failed to copy code:", err);
            alert("Failed to copy code to clipboard");
          }
        }
      }
    };

    // Handle copy events to ensure plain text is copied (no background colors)
    const handleCopy = (e) => {
      const selection = window.getSelection();
      if (selection.rangeCount > 0) {
        const range = selection.getRangeAt(0);
        const container = range.commonAncestorContainer;
        
        // Only handle if copying from message text
        if (container.nodeType === Node.TEXT_NODE || container.closest('.message-text')) {
          const plainText = selection.toString();
          if (plainText) {
            e.clipboardData.setData('text/plain', plainText);
            e.preventDefault();
          }
        }
      }
    };

    document.addEventListener("click", handleCopyClick);
    document.addEventListener("copy", handleCopy);
    return () => {
      document.removeEventListener("click", handleCopyClick);
      document.removeEventListener("copy", handleCopy);
    };
  }, [messages]);

  // Scroll to the very bottom when a new user message is added
  useEffect(() => {
    if (!messages || messages.length === 0) {
      previousMessageCountRef.current = 0;
      return;
    }

    const prevCount = previousMessageCountRef.current;
    const newCount = messages.length;
    const lastMessage = messages[newCount - 1];

    previousMessageCountRef.current = newCount;

    if (newCount > prevCount && lastMessage?.role === "user") {
      if (messagesEndRef.current) {
        messagesEndRef.current.scrollIntoView({
          behavior: "smooth",
          block: "end",
        });
      }
    }
  }, [messages]);

  const handleSubmit = (e) => {
    e.preventDefault();
    if (inputMessage.trim() && !loading) {
      onSendMessage(inputMessage.trim());
      setInputMessage("");

      // Reset textarea height after sending
      if (inputRef.current) {
        inputRef.current.style.height = "auto";
      }
    }
  };

  // submits prompt
  const handleKeyPress = (e) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      handleSubmit(e);
    }
  };

  // handles the message itself
  const handleInputChange = (e) => {
    setInputMessage(e.target.value);

    // Auto-resize textarea
    const textarea = e.target;
    textarea.style.height = "auto";
    const newHeight = Math.min(textarea.scrollHeight, 120);
    textarea.style.height = newHeight + "px";

    // If we've reached max height, ensure we can scroll
    if (textarea.scrollHeight > 120) {
      textarea.style.overflowY = "auto";
    } else {
      textarea.style.overflowY = "hidden";
    }
  };

  // handles when we're clicked on the input
  const handleInputFocus = (e) => {
    // Reset height when focusing
    const textarea = e.target;
    textarea.style.height = "auto";
    const newHeight = Math.min(textarea.scrollHeight, 120);
    textarea.style.height = newHeight + "px";

    // Handle scrolling
    if (textarea.scrollHeight > 120) {
      textarea.style.overflowY = "auto";
    } else {
      textarea.style.overflowY = "hidden";
    }
  };

  // Handle clicking anywhere in the input container to focus the textarea
  const handleContainerClick = (e) => {
    // Only focus if the click wasn't on the button
    if (e.target.tagName !== "BUTTON" && inputRef.current) {
      inputRef.current.focus();
    }
  };

  const formatTime = (timestamp) => {
    return new Date(timestamp).toLocaleTimeString([], {
      hour: "2-digit",
      minute: "2-digit",
    });
  };

  return (
    <div className="chat-window">
      <div className="chat-header">
        <div className="chat-title">
          <PromptlyMascot size={30} />
          <h2>prompt.ly</h2>
        </div>
        {isTerse && (
          <div className="terse-warning">
            <AlertTriangle size={16} />
            <span>Responses are being limited due to low prompt quality</span>
          </div>
        )}
      </div>

      <div className="messages-container" ref={messagesContainerRef}>
        {messages.length === 0 ? (
          <div className="empty-chat">
            <img src={logo} alt="Prompt.ly" className="empty-logo" />
            <h3>Start a conversation</h3>
            <p>
              Ask me anything! I'll provide helpful responses and feedback on
              your prompts.
            </p>
          </div>
        ) : (
          messages
            .filter((message) => message.content && message.content.trim())
            .map((message, index) => (
              <div
                key={index}
                className={`message ${
                  message.role === "user" ? "user-message" : "ai-message"
                }`}
              >
                <div className="message-avatar">
                  {message.role === "user" ? (
                    user?.picture && !userImageError ? (
                      <img
                        src={user.picture}
                        alt={user.name || "User"}
                        className="user-avatar-image"
                        crossOrigin="anonymous"
                        referrerPolicy="no-referrer"
                        onError={() => setUserImageError(true)}
                      />
                    ) : (
                      <div className="user-avatar-fallback">
                        <User size={24} />
                      </div>
                    )
                  ) : (
                    <PromptlyMascot size={24} />
                  )}
                </div>
                <div className="message-content">
                  <div
                    className={`message-text ${
                      message._streaming ? "streaming" : ""
                    }`}
                  >
                    {renderMarkdown(message.content)}
                  </div>
                  <div className="message-time">
                    {formatTime(message.timestamp)}
                  </div>
                </div>
              </div>
            ))
        )}
        {loading && !messages.some((msg) => msg._streaming) && (
          <div className="message ai-message">
            <div className="message-avatar">
              <PromptlyMascot size={24} />
            </div>
            <div className="message-content">
              <div className="typing-indicator">
                <span></span>
                <span></span>
                <span></span>
              </div>
            </div>
          </div>
        )}
        <div ref={messagesEndRef} />
      </div>

      {isLimitReached ? (
        <div className="conversation-limit-message">
          <p>
            <strong>
              You have reached the limit of 20 messages. Please open another
              conversation.
            </strong>
          </p>
        </div>
      ) : (
        <form className="input-form" onSubmit={handleSubmit}>
          <div className="input-container" onClick={handleContainerClick}>
            <textarea
              ref={inputRef}
              value={inputMessage}
              onChange={handleInputChange}
              onKeyPress={handleKeyPress}
              onFocus={handleInputFocus}
              placeholder="Type your message here..."
              className="message-input"
              rows="1"
              disabled={loading}
            />
            <button
              type="submit"
              className="send-button"
              disabled={!inputMessage.trim() || loading}
            >
              <Send size={18} />
            </button>
          </div>
        </form>
      )}
    </div>
  );
};

export default ChatWindow;
