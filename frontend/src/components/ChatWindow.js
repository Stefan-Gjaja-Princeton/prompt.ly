// IMPORTANT NOTE: This and the associated css file were generated by Cursor with a lot of back-and-forth - I have very little
//experience with frontend development, especially using React, so it could help me implement
//things that I was more familiar with in this language.
import React, { useState, useRef, useEffect } from "react";
import { createPortal } from "react-dom";
import { useAuth0 } from "@auth0/auth0-react";
import { Send, User, AlertTriangle, Paperclip, X } from "lucide-react";
import "./ChatWindow.css";
import logo from "../assets/promptly_logo.png";
import { renderMarkdown } from "../utils/markdown";
import PromptlyMascot from "./icons/IconMascot";

const ChatWindow = ({
  messages,
  onSendMessage,
  loading,
  isTerse,
  isLimitReached = false,
}) => {
  const { user } = useAuth0();
  const [userImageError, setUserImageError] = useState(false);
  const [inputMessage, setInputMessage] = useState("");
  const [selectedFiles, setSelectedFiles] = useState([]); // Array of files with previews
  const [isDragging, setIsDragging] = useState(false);
  const [notification, setNotification] = useState(null); // For popup notifications
  const [notificationPosition, setNotificationPosition] = useState(null); // Position calculated once and frozen
  const messagesEndRef = useRef(null);
  const messagesContainerRef = useRef(null);
  const inputRef = useRef(null);
  const fileInputRef = useRef(null);
  const fileInputWrapperRef = useRef(null);
  const previousMessageCountRef = useRef(0);

  // Handle copy button clicks for code blocks so people can paste into a code editor
  useEffect(() => {
    const handleCopyClick = async (e) => {
      if (e.target.closest(".copy-code-button")) {
        const button = e.target.closest(".copy-code-button");
        const code = button.getAttribute("data-code");

        if (code) {
          try {
            // Decode HTML entities
            const tempDiv = document.createElement("div");
            tempDiv.innerHTML = code;
            const decodedCode = tempDiv.textContent || tempDiv.innerText || "";

            await navigator.clipboard.writeText(decodedCode);

            // Visual feedback - change button text temporarily to make it clear to the user that they've copied
            const originalHTML = button.innerHTML;
            button.innerHTML =
              '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M13.854 3.646a.5.5 0 0 1 0 .708l-7 7a.5.5 0 0 1-.708 0l-3.5-3.5a.5.5 0 1 1 .708-.708L6.5 10.293l6.646-6.647a.5.5 0 0 1 .708 0z" fill="currentColor"/></svg>';
            button.style.color = "#28a745";

            setTimeout(() => {
              button.innerHTML = originalHTML;
              button.style.color = "";
            }, 2000);
          } catch (err) {
            console.error("Failed to copy code:", err);
            alert("Failed to copy code to clipboard");
          }
        }
      }
    };

    // Handle copy events to ensure plain text is copied (no background colors)
    const handleCopy = (e) => {
      const selection = window.getSelection();
      if (selection.rangeCount > 0) {
        const range = selection.getRangeAt(0);
        const container = range.commonAncestorContainer;

        // Only handle if copying from message text
        if (
          container.nodeType === Node.TEXT_NODE ||
          container.closest(".message-text")
        ) {
          // make this plain so people don't have weird formatting when they paste
          const plainText = selection.toString();
          if (plainText) {
            e.clipboardData.setData("text/plain", plainText);
            e.preventDefault();
          }
        }
      }
    };

    document.addEventListener("click", handleCopyClick);
    document.addEventListener("copy", handleCopy);
    return () => {
      document.removeEventListener("click", handleCopyClick);
      document.removeEventListener("copy", handleCopy);
    };
  }, [messages]);

  // Scroll to the very bottom when a new user message is added
  useEffect(() => {
    if (!messages || messages.length === 0) {
      previousMessageCountRef.current = 0;
      return;
    }

    const prevCount = previousMessageCountRef.current;
    const newCount = messages.length;
    const lastMessage = messages[newCount - 1];

    previousMessageCountRef.current = newCount;

    if (newCount > prevCount && lastMessage?.role === "user") {
      if (messagesEndRef.current) {
        messagesEndRef.current.scrollIntoView({
          behavior: "smooth",
          block: "end",
        });
      }
    }
  }, [messages]);

  // this runs when they submit their prompt
  const handleSubmit = (e) => {
    e.preventDefault();
    if ((inputMessage.trim() || selectedFiles.length > 0) && !loading) {
      // Send all selected files (up to 3)
      onSendMessage(
        inputMessage.trim(),
        selectedFiles.length > 0 ? selectedFiles : null
      );
      setInputMessage("");
      setSelectedFiles([]);

      // Reset textarea height after sending
      if (inputRef.current) {
        inputRef.current.style.height = "auto";
      }
    }
  };

  // submits prompt
  const handleKeyPress = (e) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      handleSubmit(e);
    }
  };

  // handles the message itself
  const handleInputChange = (e) => {
    setInputMessage(e.target.value);

    // Auto-resize textarea if the user types enough
    const textarea = e.target;
    textarea.style.height = "auto";
    const newHeight = Math.min(textarea.scrollHeight, 120);
    textarea.style.height = newHeight + "px";

    // If we've reached max height, ensure we can scroll
    if (textarea.scrollHeight > 120) {
      textarea.style.overflowY = "auto";
    } else {
      textarea.style.overflowY = "hidden";
    }
  };

  // handles when we're clicked on the input
  const handleInputFocus = (e) => {
    // Reset height when focusing
    const textarea = e.target;
    textarea.style.height = "auto";
    const newHeight = Math.min(textarea.scrollHeight, 120);
    textarea.style.height = newHeight + "px";

    // Handle scrolling
    if (textarea.scrollHeight > 120) {
      textarea.style.overflowY = "auto";
    } else {
      textarea.style.overflowY = "hidden";
    }
  };

  // Handle clicking anywhere in the input container to focus the textarea
  const handleContainerClick = (e) => {
    // Only focus if the click wasn't on the button
    if (e.target.tagName !== "BUTTON" && inputRef.current) {
      inputRef.current.focus();
    }
  };

  // Show notification popup
  const showNotification = (message) => {
    // Calculate position synchronously once and then freeze it
    let position = { top: 0, left: 0 };
    if (fileInputWrapperRef.current) {
      const rect = fileInputWrapperRef.current.getBoundingClientRect();
      position = {
        top: rect.top, // Viewport-relative position
        left: rect.left + rect.width / 2, // Center horizontally
      };
    }
    // Set position first, then notification
    setNotificationPosition(position);
    setNotification(message);
    setTimeout(() => {
      setNotification(null);
      setNotificationPosition(null);
    }, 3000); // Hide after 3 seconds
  };

  // Helper function to validate and process a file
  const processFile = (file, showErrorNotification = true) => {
    // Validate file type (images and PDFs)
    const isValidType =
      file.type.startsWith("image/") ||
      file.type === "application/pdf" ||
      file.name.toLowerCase().endsWith(".pdf") ||
      file.name.toLowerCase().endsWith(".png") ||
      file.name.toLowerCase().endsWith(".jpg") ||
      file.name.toLowerCase().endsWith(".jpeg");

    // i just covered the main file types to not worry about it too much
    if (!isValidType) {
      if (showErrorNotification) {
        showNotification("Filetypes supported: PDF, PNG, JPG");
      }
      return null;
    }

    // Validate file size (max 10MB)
    const maxSize = 10 * 1024 * 1024; // 10MB
    if (file.size > maxSize) {
      if (showErrorNotification) {
        showNotification("File size must be less than 10MB");
      }
      return null;
    }

    return file;
  };

  // Helper function to create file preview object (so when users attach they can see a little thumbnail of what they've attached)
  const createFilePreview = (file, callback) => {
    const isImage =
      file.type.startsWith("image/") ||
      file.name.toLowerCase().match(/\.(png|jpg|jpeg)$/i);

    if (isImage) {
      const reader = new FileReader();
      reader.onload = (e) => {
        callback({
          file,
          preview: e.target.result,
          type: "image",
        });
      };
      reader.onerror = () => {
        alert("Failed to read file. Please try again.");
        callback(null);
      };
      reader.readAsDataURL(file);
    } else {
      // PDF - no preview image, just metadata
      callback({
        file,
        preview: null,
        type: "pdf",
      });
    }
  };

  // Handle file selection
  const handleFileSelect = (e) => {
    const file = e.target.files?.[0];
    if (!file) {
      return;
    }

    // Check if we already have 3 files
    if (selectedFiles.length >= 3) {
      showNotification("Only 3 files are allowed");
      // Reset file input
      if (fileInputRef.current) {
        fileInputRef.current.value = "";
      }
      return;
    }

    const validFile = processFile(file);
    if (!validFile) {
      // Reset file input
      if (fileInputRef.current) {
        fileInputRef.current.value = "";
      }
      return;
    }

    createFilePreview(validFile, (filePreviewObj) => {
      if (filePreviewObj) {
        setSelectedFiles((prev) => [...prev, filePreviewObj]);
      }
    });

    // Reset file input
    if (fileInputRef.current) {
      fileInputRef.current.value = "";
    }
  };

  // Remove selected file by index
  const handleRemoveFile = (index, e) => {
    e.stopPropagation();
    setSelectedFiles((prev) => prev.filter((_, i) => i !== index));
  };

  // Handle drag and drop
  const handleDragEnter = (e) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragging(true);
  };

  const handleDragLeave = (e) => {
    e.preventDefault();
    e.stopPropagation();
    // Only set isDragging to false if we're leaving the chat window entirely
    if (!e.currentTarget.contains(e.relatedTarget)) {
      setIsDragging(false);
    }
  };

  const handleDragOver = (e) => {
    e.preventDefault();
    e.stopPropagation();
  };

  const handleDrop = (e) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragging(false);

    const files = e.dataTransfer.files;
    if (files && files.length > 0) {
      // Check if adding files would exceed the limit
      const currentCount = selectedFiles.length;
      const filesToAdd = Array.from(files).slice(0, 3 - currentCount);

      if (files.length > filesToAdd.length) {
        showNotification("Only 3 files are allowed");
      }

      filesToAdd.forEach((file) => {
        const validFile = processFile(file);
        if (!validFile) return;

        createFilePreview(validFile, (filePreviewObj) => {
          if (filePreviewObj) {
            setSelectedFiles((prev) => [...prev, filePreviewObj]);
          }
        });
      });
    }
  };

  // so that times display properly for the messages users send
  const formatTime = (timestamp) => {
    return new Date(timestamp).toLocaleTimeString([], {
      hour: "2-digit",
      minute: "2-digit",
    });
  };

  return (
    <div
      className={`chat-window ${isDragging ? "drag-over" : ""}`}
      onDragEnter={handleDragEnter}
      onDragOver={handleDragOver}
      onDragLeave={handleDragLeave}
      onDrop={handleDrop}
    >
      <div className="chat-header">
        <div className="chat-title">
          <PromptlyMascot size={30} />
          <h2>prompt.ly</h2>
        </div>
        {isTerse && (
          <div className="terse-warning">
            <AlertTriangle size={16} />
            <span>Responses are being limited due to low prompt quality</span>
          </div>
        )}
      </div>

      {isDragging && (
        <div className="drag-overlay">
          <div className="drag-overlay-content">
            <Paperclip size={48} />
            <p>Drop your files here to attach them! (PDF, PNG, JPG)</p>
          </div>
        </div>
      )}
      <div className="messages-container" ref={messagesContainerRef}>
        {messages.length === 0 ? (
          <div className="empty-chat">
            <img src={logo} alt="Prompt.ly" className="empty-logo" />
            <h3>Start a conversation</h3>
            <p>
              Ask me anything! I'll provide helpful responses and feedback on
              your prompts.
            </p>
          </div>
        ) : (
          messages
            .filter((message) => message.content && message.content.trim())
            .map((message, index) => (
              <div
                key={index}
                className={`message ${
                  message.role === "user" ? "user-message" : "ai-message"
                }`}
              >
                <div className="message-avatar">
                  {message.role === "user" ? (
                    user?.picture && !userImageError ? (
                      <img
                        src={user.picture}
                        alt={user.name || "User"}
                        className="user-avatar-image"
                        crossOrigin="anonymous"
                        referrerPolicy="no-referrer"
                        onError={() => setUserImageError(true)}
                      />
                    ) : (
                      <div className="user-avatar-fallback">
                        <User size={24} />
                      </div>
                    )
                  ) : (
                    <PromptlyMascot size={24} />
                  )}
                </div>
                <div className="message-content">
                  <div
                    className={`message-text ${
                      message._streaming ? "streaming" : ""
                    }`}
                  >
                    {renderMarkdown(message.content)}
                  </div>
                  <div className="message-time">
                    {formatTime(message.timestamp)}
                  </div>
                  {message.attachments && message.attachments.length > 0 && (
                    <div className="message-attachment-indicator">
                      This message had an attachment
                    </div>
                  )}
                </div>
              </div>
            ))
        )}
        {loading && !messages.some((msg) => msg._streaming) && (
          <div className="message ai-message">
            <div className="message-avatar">
              <PromptlyMascot size={24} />
            </div>
            <div className="message-content">
              <div className="typing-indicator">
                <span></span>
                <span></span>
                <span></span>
              </div>
            </div>
          </div>
        )}
        <div ref={messagesEndRef} />
      </div>

      {isLimitReached ? (
        <div className="conversation-limit-message">
          <p>
            <strong>
              You have reached the limit of 20 messages. Please open another
              conversation.
            </strong>
          </p>
        </div>
      ) : (
        <form className="input-form" onSubmit={handleSubmit}>
          {selectedFiles.length > 0 && (
            <div className="file-preview-container">
              {selectedFiles.map((fileObj, index) => (
                <div key={index} className="file-preview-item">
                  {fileObj.type === "image" ? (
                    <img
                      src={fileObj.preview}
                      alt={fileObj.file.name}
                      className="file-preview-image"
                      title={fileObj.file.name}
                    />
                  ) : (
                    <div className="file-preview-pdf" title={fileObj.file.name}>
                      <Paperclip size={20} />
                      <span className="file-preview-pdf-name">
                        {fileObj.file.name}
                      </span>
                    </div>
                  )}
                  <button
                    type="button"
                    className="file-preview-remove"
                    onClick={(e) => handleRemoveFile(index, e)}
                    title="Remove file"
                  >
                    <X size={14} />
                  </button>
                </div>
              ))}
            </div>
          )}
          <div className="input-container" onClick={handleContainerClick}>
            <div className="file-input-wrapper" ref={fileInputWrapperRef}>
              <input
                ref={fileInputRef}
                type="file"
                accept="image/*,.pdf,image/png,image/jpeg,application/pdf"
                onChange={handleFileSelect}
                className="file-input-hidden"
                id="file-input"
                disabled={loading || selectedFiles.length >= 3}
              />
              <label
                htmlFor="file-input"
                className={`file-input-label ${
                  selectedFiles.length >= 3 ? "disabled" : ""
                }`}
                title={
                  selectedFiles.length >= 3
                    ? "Maximum 3 files allowed"
                    : "Attach file (PDF, PNG, JPG)"
                }
              >
                <Paperclip size={18} />
                {selectedFiles.length > 0 && (
                  <span className="file-count-badge">
                    {selectedFiles.length}
                  </span>
                )}
              </label>
            </div>
            <textarea
              ref={inputRef}
              value={inputMessage}
              onChange={handleInputChange}
              onKeyPress={handleKeyPress}
              onFocus={handleInputFocus}
              placeholder="Type your message here..."
              className="message-input"
              rows="1"
            />
            <button
              type="submit"
              className="send-button"
              disabled={
                (!inputMessage.trim() && selectedFiles.length === 0) || loading
              }
            >
              <Send size={18} />
            </button>
          </div>
          <div className="input-disclaimer">
            prompt.ly can make mistakes. Check important info.
          </div>
        </form>
      )}
      {notification &&
        notificationPosition &&
        createPortal(
          <div
            className="file-notification-popup"
            style={{
              top: `${notificationPosition.top}px`,
              left: `${notificationPosition.left}px`,
            }}
          >
            {notification}
          </div>,
          document.body
        )}
    </div>
  );
};

export default ChatWindow;
